<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Astrohelion: astrohelion::BaseArcset Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Astrohelion
   </div>
   <div id="projectbrief">An open source multi-body astrodynamics toolkit for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceastrohelion.html">astrohelion</a></li><li class="navelem"><a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classastrohelion_1_1_base_arcset-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">astrohelion::BaseArcset Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract class that provides the framework for trajectories and nodesets.  
 <a href="classastrohelion_1_1_base_arcset.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_base_arcset_8hpp_source.html">BaseArcset.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for astrohelion::BaseArcset:</div>
<div class="dyncontent">
<div class="center"><img src="classastrohelion_1_1_base_arcset__inherit__graph.png" border="0" usemap="#astrohelion_1_1_base_arcset_inherit__map" alt="Inheritance graph"/></div>
<map name="astrohelion_1_1_base_arcset_inherit__map" id="astrohelion_1_1_base_arcset_inherit__map">
<area shape="rect" id="node3" href="classastrohelion_1_1_arcset.html" title="Extends BaseArcset in a few areas. " alt="" coords="384,97,515,124"/>
<area shape="rect" id="node2" href="classastrohelion_1_1_core.html" title="An object that serves as a parent to all Core objects. " alt="" coords="5,97,127,124"/>
<area shape="rect" id="node4" href="classastrohelion_1_1_arcset__2bp.html" title="Supplies functions specific to 2BP arcsets. " alt="" coords="563,5,721,32"/>
<area shape="rect" id="node5" href="classastrohelion_1_1_arcset__bc4bp.html" title="Supplies functions specific to BC4BP arcsets. " alt="" coords="577,57,707,98"/>
<area shape="rect" id="node6" href="classastrohelion_1_1_arcset__cr3bp.html" title="Supplies functions specific to CR3BP arcsets. " alt="" coords="577,122,707,163"/>
<area shape="rect" id="node8" href="classastrohelion_1_1_arcset__periodic.html" title="[brief description] " alt="" coords="577,187,707,229"/>
<area shape="rect" id="node7" href="classastrohelion_1_1_arcset__cr3bp__lt.html" title="Supplies functions specific to low&#45;thrust CR3BP arcsets. " alt="" coords="769,122,900,163"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for astrohelion::BaseArcset:</div>
<div class="dyncontent">
<div class="center"><img src="classastrohelion_1_1_base_arcset__coll__graph.png" border="0" usemap="#astrohelion_1_1_base_arcset_coll__map" alt="Collaboration graph"/></div>
<map name="astrohelion_1_1_base_arcset_coll__map" id="astrohelion_1_1_base_arcset_coll__map">
<area shape="rect" id="node2" href="classastrohelion_1_1_core.html" title="An object that serves as a parent to all Core objects. " alt="" coords="39,5,160,32"/>
<area shape="rect" id="node3" href="classastrohelion_1_1_sys_data.html" title="Contains information about a system, like mass ratio, primary names, etc. " alt="" coords="102,81,246,108"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a73e4344c81c81585e4d0ab261acc04ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_core___initializer.html">Core_Initializer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_core.html#a73e4344c81c81585e4d0ab261acc04ee">initializer</a> ()</td></tr>
<tr class="memdesc:a73e4344c81c81585e4d0ab261acc04ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the core.  <a href="#a73e4344c81c81585e4d0ab261acc04ee">More...</a><br /></td></tr>
<tr class="separator:a73e4344c81c81585e4d0ab261acc04ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfdae6510479237fe18dfb11aea1c8f"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_core.html#a5cfdae6510479237fe18dfb11aea1c8f">bIsInit</a> ()</td></tr>
<tr class="memdesc:a5cfdae6510479237fe18dfb11aea1c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if the core is initialized.  <a href="#a5cfdae6510479237fe18dfb11aea1c8f">More...</a><br /></td></tr>
<tr class="separator:a5cfdae6510479237fe18dfb11aea1c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">*structors</div></td></tr>
<tr class="memitem:ac06ebd04201c41361ba88f1520c29831"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ac06ebd04201c41361ba88f1520c29831">BaseArcset</a> (const <a class="el" href="classastrohelion_1_1_sys_data.html">SysData</a> *)</td></tr>
<tr class="memdesc:ac06ebd04201c41361ba88f1520c29831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor (requires system data object)  <a href="#ac06ebd04201c41361ba88f1520c29831">More...</a><br /></td></tr>
<tr class="separator:ac06ebd04201c41361ba88f1520c29831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c51a6432f01a36b9777447d699d5854"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a6c51a6432f01a36b9777447d699d5854">BaseArcset</a> (const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> &amp;)</td></tr>
<tr class="memdesc:a6c51a6432f01a36b9777447d699d5854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a6c51a6432f01a36b9777447d699d5854">More...</a><br /></td></tr>
<tr class="separator:a6c51a6432f01a36b9777447d699d5854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7f01caf2355c9bda9c19839d6e14cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c7f01caf2355c9bda9c19839d6e14cc"></a>
virtual <a class="el" href="namespaceastrohelion.html#aeaa70ec99fac6fdcb0fe277fdbe92e16">baseArcsetPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a4c7f01caf2355c9bda9c19839d6e14cc">create</a> (const <a class="el" href="classastrohelion_1_1_sys_data.html">SysData</a> *) const =0</td></tr>
<tr class="memdesc:a4c7f01caf2355c9bda9c19839d6e14cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor for creation (virtual constructor idiom) <br /></td></tr>
<tr class="separator:a4c7f01caf2355c9bda9c19839d6e14cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998a3d0fbabfb06245faf4fde28eaf1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a998a3d0fbabfb06245faf4fde28eaf1c"></a>
virtual <a class="el" href="namespaceastrohelion.html#aeaa70ec99fac6fdcb0fe277fdbe92e16">baseArcsetPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a998a3d0fbabfb06245faf4fde28eaf1c">clone</a> () const =0</td></tr>
<tr class="memdesc:a998a3d0fbabfb06245faf4fde28eaf1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual constructor for copying (virtual constructor idiom) <br /></td></tr>
<tr class="separator:a998a3d0fbabfb06245faf4fde28eaf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ed419c09ee131a563e0513a6c12273"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94ed419c09ee131a563e0513a6c12273"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a94ed419c09ee131a563e0513a6c12273">~BaseArcset</a> ()</td></tr>
<tr class="memdesc:a94ed419c09ee131a563e0513a6c12273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a94ed419c09ee131a563e0513a6c12273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Set and Get Functions</div></td></tr>
<tr class="memitem:a014401d1bd70ff3652271769ef1be598"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classastrohelion_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a014401d1bd70ff3652271769ef1be598">getArcConstraints</a> () const </td></tr>
<tr class="memdesc:a014401d1bd70ff3652271769ef1be598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a vector containing all the constraints applied to this arcset object.  <a href="#a014401d1bd70ff3652271769ef1be598">More...</a><br /></td></tr>
<tr class="separator:a014401d1bd70ff3652271769ef1be598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459186fb23b639d6f7925deae21a4a55"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classastrohelion_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a459186fb23b639d6f7925deae21a4a55">getAllConstraints</a> () const </td></tr>
<tr class="memdesc:a459186fb23b639d6f7925deae21a4a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a vector containing all the constraints applied to the arcset, nodes, and segments.  <a href="#a459186fb23b639d6f7925deae21a4a55">More...</a><br /></td></tr>
<tr class="separator:a459186fb23b639d6f7925deae21a4a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd55faf6c1bb134d0269de20bc68b57a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structastrohelion_1_1_arc_piece.html">ArcPiece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#afd55faf6c1bb134d0269de20bc68b57a">getChronoOrder</a> () const </td></tr>
<tr class="memdesc:afd55faf6c1bb134d0269de20bc68b57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine what order to place the nodes and segments of this object into to achieve a chronological progression in forward time.  <a href="#afd55faf6c1bb134d0269de20bc68b57a">More...</a><br /></td></tr>
<tr class="separator:afd55faf6c1bb134d0269de20bc68b57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a43ec879c5c350281f0242ad64835a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab0a43ec879c5c350281f0242ad64835a">getCoord</a> (unsigned int) const </td></tr>
<tr class="memdesc:ab0a43ec879c5c350281f0242ad64835a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of one coordinate for all nodes.  <a href="#ab0a43ec879c5c350281f0242ad64835a">More...</a><br /></td></tr>
<tr class="separator:ab0a43ec879c5c350281f0242ad64835a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a82f9aca02c373dc08b1dabc84ccd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a24a82f9aca02c373dc08b1dabc84ccd0">getCtrlLawByIx</a> (int)</td></tr>
<tr class="memdesc:a24a82f9aca02c373dc08b1dabc84ccd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a pointer to the control law for a segment at the specified index.  <a href="#a24a82f9aca02c373dc08b1dabc84ccd0">More...</a><br /></td></tr>
<tr class="separator:a24a82f9aca02c373dc08b1dabc84ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50af3f821077ee2de2c9f290f4faddd2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a50af3f821077ee2de2c9f290f4faddd2">getCtrlLawByIx_const</a> (int) const </td></tr>
<tr class="memdesc:a50af3f821077ee2de2c9f290f4faddd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a constant pointer to the control law for a segment at the specified index.  <a href="#a50af3f821077ee2de2c9f290f4faddd2">More...</a><br /></td></tr>
<tr class="separator:a50af3f821077ee2de2c9f290f4faddd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6f06a5c4c7d6f88207ecb715f0f375"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a9a6f06a5c4c7d6f88207ecb715f0f375">getEpoch</a> (int) const </td></tr>
<tr class="memdesc:a9a6f06a5c4c7d6f88207ecb715f0f375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the epoch associated with a node with the specified ID.  <a href="#a9a6f06a5c4c7d6f88207ecb715f0f375">More...</a><br /></td></tr>
<tr class="separator:a9a6f06a5c4c7d6f88207ecb715f0f375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1975e8ad1906e4a99edb7e6f5b88f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#afc1975e8ad1906e4a99edb7e6f5b88f4">getEpochByIx</a> (int) const </td></tr>
<tr class="memdesc:afc1975e8ad1906e4a99edb7e6f5b88f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the epoch of a specific node.  <a href="#afc1975e8ad1906e4a99edb7e6f5b88f4">More...</a><br /></td></tr>
<tr class="separator:afc1975e8ad1906e4a99edb7e6f5b88f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9aa231608a7b0b6e1e77a6127ceb17"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a8f9aa231608a7b0b6e1e77a6127ceb17">getEpochs</a> () const </td></tr>
<tr class="memdesc:a8f9aa231608a7b0b6e1e77a6127ceb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a vector of all epoch values for the nodes.  <a href="#a8f9aa231608a7b0b6e1e77a6127ceb17">More...</a><br /></td></tr>
<tr class="separator:a8f9aa231608a7b0b6e1e77a6127ceb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190825543c9210190a8fedc9fb790ea1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a190825543c9210190a8fedc9fb790ea1">getExtraParamByIx</a> (int, std::string) const </td></tr>
<tr class="memdesc:a190825543c9210190a8fedc9fb790ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a set of extra parameters for the specified node.  <a href="#a190825543c9210190a8fedc9fb790ea1">More...</a><br /></td></tr>
<tr class="separator:a190825543c9210190a8fedc9fb790ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e27fd3b9e892c6a6bba0dde9e24c48"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a74e27fd3b9e892c6a6bba0dde9e24c48">getExtraParamVecByIx</a> (int, std::string) const </td></tr>
<tr class="memdesc:a74e27fd3b9e892c6a6bba0dde9e24c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a set of extra parameters for the specified node.  <a href="#a74e27fd3b9e892c6a6bba0dde9e24c48">More...</a><br /></td></tr>
<tr class="separator:a74e27fd3b9e892c6a6bba0dde9e24c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf13d19c108c337b7c45d00544cca90a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#adf13d19c108c337b7c45d00544cca90a">getNextNodeID</a> () const </td></tr>
<tr class="memdesc:adf13d19c108c337b7c45d00544cca90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of the ID that will be assigned to the next node added to this arcset object.  <a href="#adf13d19c108c337b7c45d00544cca90a">More...</a><br /></td></tr>
<tr class="separator:adf13d19c108c337b7c45d00544cca90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c83f400ec6308753424eb22f1182443"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a8c83f400ec6308753424eb22f1182443">getNextSegID</a> () const </td></tr>
<tr class="memdesc:a8c83f400ec6308753424eb22f1182443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the value of the ID that will be assigned to the next segment added to this arcset object.  <a href="#a8c83f400ec6308753424eb22f1182443">More...</a><br /></td></tr>
<tr class="separator:a8c83f400ec6308753424eb22f1182443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268ad635b718e419d7d11757854d83e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a268ad635b718e419d7d11757854d83e2">getNode</a> (int) const </td></tr>
<tr class="memdesc:a268ad635b718e419d7d11757854d83e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a specific node.  <a href="#a268ad635b718e419d7d11757854d83e2">More...</a><br /></td></tr>
<tr class="separator:a268ad635b718e419d7d11757854d83e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e6a1b8bcb05ddb858b41166ca6b684"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aa9e6a1b8bcb05ddb858b41166ca6b684">getNodeByIx</a> (int) const </td></tr>
<tr class="memdesc:aa9e6a1b8bcb05ddb858b41166ca6b684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a node based on its index in the storage array.  <a href="#aa9e6a1b8bcb05ddb858b41166ca6b684">More...</a><br /></td></tr>
<tr class="separator:aa9e6a1b8bcb05ddb858b41166ca6b684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c03c3694d6dab55eb7db18eb56512b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aa4c03c3694d6dab55eb7db18eb56512b">getNodeRef</a> (int)</td></tr>
<tr class="memdesc:aa4c03c3694d6dab55eb7db18eb56512b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a specific node.  <a href="#aa4c03c3694d6dab55eb7db18eb56512b">More...</a><br /></td></tr>
<tr class="separator:aa4c03c3694d6dab55eb7db18eb56512b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad21ca59da053746b01b80346897c304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aad21ca59da053746b01b80346897c304">getNodeRefByIx</a> (int)</td></tr>
<tr class="memdesc:aad21ca59da053746b01b80346897c304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a node based on its index in the storage array.  <a href="#aad21ca59da053746b01b80346897c304">More...</a><br /></td></tr>
<tr class="separator:aad21ca59da053746b01b80346897c304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf2eea0d243cd3b0aadae9f3c5a2d13"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classastrohelion_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a9bf2eea0d243cd3b0aadae9f3c5a2d13">getNodeRef_const</a> (int) const </td></tr>
<tr class="memdesc:a9bf2eea0d243cd3b0aadae9f3c5a2d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a specific node.  <a href="#a9bf2eea0d243cd3b0aadae9f3c5a2d13">More...</a><br /></td></tr>
<tr class="separator:a9bf2eea0d243cd3b0aadae9f3c5a2d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088f0aa4d9f024c237b984f38e9f76c8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classastrohelion_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a088f0aa4d9f024c237b984f38e9f76c8">getNodeRefByIx_const</a> (int) const </td></tr>
<tr class="memdesc:a088f0aa4d9f024c237b984f38e9f76c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a node based on its index in the storage array.  <a href="#a088f0aa4d9f024c237b984f38e9f76c8">More...</a><br /></td></tr>
<tr class="separator:a088f0aa4d9f024c237b984f38e9f76c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75866ed5ba5c199db71c555f7ea9445"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ae75866ed5ba5c199db71c555f7ea9445">getNodeIx</a> (int) const </td></tr>
<tr class="memdesc:ae75866ed5ba5c199db71c555f7ea9445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of a specific node within the node storage vector.  <a href="#ae75866ed5ba5c199db71c555f7ea9445">More...</a><br /></td></tr>
<tr class="separator:ae75866ed5ba5c199db71c555f7ea9445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab815c98024400676fc79b40c1a7cfa30"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab815c98024400676fc79b40c1a7cfa30">getNumCons</a> () const </td></tr>
<tr class="memdesc:ab815c98024400676fc79b40c1a7cfa30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the total number of constraints contained by all nodes, segments, and the arcset object itself.  <a href="#ab815c98024400676fc79b40c1a7cfa30">More...</a><br /></td></tr>
<tr class="separator:ab815c98024400676fc79b40c1a7cfa30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210919d8b4ba59f07644c73962f4f058"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a210919d8b4ba59f07644c73962f4f058">getNumNodes</a> () const </td></tr>
<tr class="memdesc:a210919d8b4ba59f07644c73962f4f058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of nodes.  <a href="#a210919d8b4ba59f07644c73962f4f058">More...</a><br /></td></tr>
<tr class="separator:a210919d8b4ba59f07644c73962f4f058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58515de87209d9c0b5b0a6f6f7a8104"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab58515de87209d9c0b5b0a6f6f7a8104">getNumSegs</a> () const </td></tr>
<tr class="memdesc:ab58515de87209d9c0b5b0a6f6f7a8104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of segments.  <a href="#ab58515de87209d9c0b5b0a6f6f7a8104">More...</a><br /></td></tr>
<tr class="separator:ab58515de87209d9c0b5b0a6f6f7a8104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9135d17bd10f1cf03ea6ccaf75f8a4a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a9135d17bd10f1cf03ea6ccaf75f8a4a5">getSeg</a> (int) const </td></tr>
<tr class="memdesc:a9135d17bd10f1cf03ea6ccaf75f8a4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a specific node.  <a href="#a9135d17bd10f1cf03ea6ccaf75f8a4a5">More...</a><br /></td></tr>
<tr class="separator:a9135d17bd10f1cf03ea6ccaf75f8a4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547c71fcc8d59f6d9e631b1bfb3a3f95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a547c71fcc8d59f6d9e631b1bfb3a3f95">getSegByIx</a> (int) const </td></tr>
<tr class="memdesc:a547c71fcc8d59f6d9e631b1bfb3a3f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a segment based on its index in the storage array.  <a href="#a547c71fcc8d59f6d9e631b1bfb3a3f95">More...</a><br /></td></tr>
<tr class="separator:a547c71fcc8d59f6d9e631b1bfb3a3f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb66923aa7a826982aac2bfe5d197c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#accb66923aa7a826982aac2bfe5d197c1">getSegRef</a> (int)</td></tr>
<tr class="memdesc:accb66923aa7a826982aac2bfe5d197c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a specific segment.  <a href="#accb66923aa7a826982aac2bfe5d197c1">More...</a><br /></td></tr>
<tr class="separator:accb66923aa7a826982aac2bfe5d197c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e89d328c7331cd6125b3d1c919ad50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a86e89d328c7331cd6125b3d1c919ad50">getSegRefByIx</a> (int)</td></tr>
<tr class="memdesc:a86e89d328c7331cd6125b3d1c919ad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a segment based on its index in the storage array.  <a href="#a86e89d328c7331cd6125b3d1c919ad50">More...</a><br /></td></tr>
<tr class="separator:a86e89d328c7331cd6125b3d1c919ad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8703ec3145e2d9ea684d8c41ee0c602c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a8703ec3145e2d9ea684d8c41ee0c602c">getSegRef_const</a> (int) const </td></tr>
<tr class="memdesc:a8703ec3145e2d9ea684d8c41ee0c602c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a specific segment.  <a href="#a8703ec3145e2d9ea684d8c41ee0c602c">More...</a><br /></td></tr>
<tr class="separator:a8703ec3145e2d9ea684d8c41ee0c602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582e0a4b759f776e971313156e7c5aef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a582e0a4b759f776e971313156e7c5aef">getSegRefByIx_const</a> (int) const </td></tr>
<tr class="memdesc:a582e0a4b759f776e971313156e7c5aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to a segment based on its index in the storage array.  <a href="#a582e0a4b759f776e971313156e7c5aef">More...</a><br /></td></tr>
<tr class="separator:a582e0a4b759f776e971313156e7c5aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffb92a2c0d733d5958f30cb93d41397"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a9ffb92a2c0d733d5958f30cb93d41397">getSegIx</a> (int) const </td></tr>
<tr class="memdesc:a9ffb92a2c0d733d5958f30cb93d41397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the index of a specific node within the node storage vector.  <a href="#a9ffb92a2c0d733d5958f30cb93d41397">More...</a><br /></td></tr>
<tr class="separator:a9ffb92a2c0d733d5958f30cb93d41397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad644d2e0a0438d4f8254916cf3fc08c4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ad644d2e0a0438d4f8254916cf3fc08c4">getState</a> (int) const </td></tr>
<tr class="memdesc:ad644d2e0a0438d4f8254916cf3fc08c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the state vector associated with a node with the specified ID.  <a href="#ad644d2e0a0438d4f8254916cf3fc08c4">More...</a><br /></td></tr>
<tr class="separator:ad644d2e0a0438d4f8254916cf3fc08c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07886ce3596a1506a12ff88d7b6d9faa"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a07886ce3596a1506a12ff88d7b6d9faa">getStateByIx</a> (int) const </td></tr>
<tr class="memdesc:a07886ce3596a1506a12ff88d7b6d9faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a position-velocity state on the arc.  <a href="#a07886ce3596a1506a12ff88d7b6d9faa">More...</a><br /></td></tr>
<tr class="separator:a07886ce3596a1506a12ff88d7b6d9faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b1d7ae815f2e956dae57d13cc82ad5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a21b1d7ae815f2e956dae57d13cc82ad5">getStateDeriv</a> (int)</td></tr>
<tr class="memdesc:a21b1d7ae815f2e956dae57d13cc82ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the state derivative vector associated with a node with the specified ID.  <a href="#a21b1d7ae815f2e956dae57d13cc82ad5">More...</a><br /></td></tr>
<tr class="separator:a21b1d7ae815f2e956dae57d13cc82ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d83e52bdd9bce7b98952229d34cd3a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a91d83e52bdd9bce7b98952229d34cd3a">getStateDerivByIx</a> (int)</td></tr>
<tr class="memdesc:a91d83e52bdd9bce7b98952229d34cd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an acceleration on the arc.  <a href="#a91d83e52bdd9bce7b98952229d34cd3a">More...</a><br /></td></tr>
<tr class="separator:a91d83e52bdd9bce7b98952229d34cd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab556be1b6fce4637ee8589d5ba5f92df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab556be1b6fce4637ee8589d5ba5f92df">getSTM</a> (int) const </td></tr>
<tr class="memdesc:ab556be1b6fce4637ee8589d5ba5f92df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the STM associated with a segment with the specified ID.  <a href="#ab556be1b6fce4637ee8589d5ba5f92df">More...</a><br /></td></tr>
<tr class="separator:ab556be1b6fce4637ee8589d5ba5f92df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388f1be5eb8fe2a06aaba4e9da9352ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a388f1be5eb8fe2a06aaba4e9da9352ae">getSTMByIx</a> (int) const </td></tr>
<tr class="memdesc:a388f1be5eb8fe2a06aaba4e9da9352ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve an STM associated with a segment with the specified index.  <a href="#a388f1be5eb8fe2a06aaba4e9da9352ae">More...</a><br /></td></tr>
<tr class="separator:a388f1be5eb8fe2a06aaba4e9da9352ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b82ff1647ee0c1c29ef443ba0d35b5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a42b82ff1647ee0c1c29ef443ba0d35b5">getSTMElementsByIx</a> (int) const </td></tr>
<tr class="memdesc:a42b82ff1647ee0c1c29ef443ba0d35b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the elements of the STM at the specified index.  <a href="#a42b82ff1647ee0c1c29ef443ba0d35b5">More...</a><br /></td></tr>
<tr class="separator:a42b82ff1647ee0c1c29ef443ba0d35b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e822e63473e652fe9e567a9adbf5a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classastrohelion_1_1_sys_data.html">SysData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a52e822e63473e652fe9e567a9adbf5a1">getSysData</a> () const </td></tr>
<tr class="memdesc:a52e822e63473e652fe9e567a9adbf5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the a pointer to the system data object associated with this arc.  <a href="#a52e822e63473e652fe9e567a9adbf5a1">More...</a><br /></td></tr>
<tr class="separator:a52e822e63473e652fe9e567a9adbf5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bac542c52a8994739833999fe5b859"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ad7bac542c52a8994739833999fe5b859">getTOF</a> (int) const </td></tr>
<tr class="memdesc:ad7bac542c52a8994739833999fe5b859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the time-of-flight associated with a segment with the specified ID.  <a href="#ad7bac542c52a8994739833999fe5b859">More...</a><br /></td></tr>
<tr class="separator:ad7bac542c52a8994739833999fe5b859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a221ac94947dc15ad30c0a8a3f3b22"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a89a221ac94947dc15ad30c0a8a3f3b22">getTOFByIx</a> (int) const </td></tr>
<tr class="memdesc:a89a221ac94947dc15ad30c0a8a3f3b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time-of-flight for a specific segment.  <a href="#a89a221ac94947dc15ad30c0a8a3f3b22">More...</a><br /></td></tr>
<tr class="separator:a89a221ac94947dc15ad30c0a8a3f3b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d152e5b7d88e6d8184f4c1dfdf386f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ac2d152e5b7d88e6d8184f4c1dfdf386f">getTotalTOF</a> () const </td></tr>
<tr class="memdesc:ac2d152e5b7d88e6d8184f4c1dfdf386f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the total time-of-flight along this arc.  <a href="#ac2d152e5b7d88e6d8184f4c1dfdf386f">More...</a><br /></td></tr>
<tr class="separator:ac2d152e5b7d88e6d8184f4c1dfdf386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110ed64cd4f619d0d3634b9e2b0de339"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a110ed64cd4f619d0d3634b9e2b0de339">getTol</a> () const </td></tr>
<tr class="memdesc:a110ed64cd4f619d0d3634b9e2b0de339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the tolerance with which data in this object was computed.  <a href="#a110ed64cd4f619d0d3634b9e2b0de339">More...</a><br /></td></tr>
<tr class="separator:a110ed64cd4f619d0d3634b9e2b0de339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5756bb8fecfc4f22e97aa5f6f956768"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ac5756bb8fecfc4f22e97aa5f6f956768">isInChronoOrder</a> () const </td></tr>
<tr class="memdesc:ac5756bb8fecfc4f22e97aa5f6f956768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the arcset is arranged in chronological order.  <a href="#ac5756bb8fecfc4f22e97aa5f6f956768">More...</a><br /></td></tr>
<tr class="separator:ac5756bb8fecfc4f22e97aa5f6f956768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af112fc10dd6f15f81d417f9f3c9fa218"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#af112fc10dd6f15f81d417f9f3c9fa218">setEpoch</a> (int, double)</td></tr>
<tr class="memdesc:af112fc10dd6f15f81d417f9f3c9fa218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the epoch time associated with a node with the specified ID.  <a href="#af112fc10dd6f15f81d417f9f3c9fa218">More...</a><br /></td></tr>
<tr class="separator:af112fc10dd6f15f81d417f9f3c9fa218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d8b2b867f969c0e668ac69ff1e5cd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a03d8b2b867f969c0e668ac69ff1e5cd7">setEpochByIx</a> (int, double)</td></tr>
<tr class="memdesc:a03d8b2b867f969c0e668ac69ff1e5cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the epoch time for a specific node.  <a href="#a03d8b2b867f969c0e668ac69ff1e5cd7">More...</a><br /></td></tr>
<tr class="separator:a03d8b2b867f969c0e668ac69ff1e5cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea7cf208ac82e6fbcf82ed46976192f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#acea7cf208ac82e6fbcf82ed46976192f">setStateDeriv</a> (int, std::vector&lt; double &gt;)</td></tr>
<tr class="memdesc:acea7cf208ac82e6fbcf82ed46976192f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state derivative vector associated with a node with the specified ID.  <a href="#acea7cf208ac82e6fbcf82ed46976192f">More...</a><br /></td></tr>
<tr class="separator:acea7cf208ac82e6fbcf82ed46976192f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6725f4e543a5717af06a170b3ee411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a7b6725f4e543a5717af06a170b3ee411">setStateDerivByIx</a> (int, std::vector&lt; double &gt;)</td></tr>
<tr class="memdesc:a7b6725f4e543a5717af06a170b3ee411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state derivative vector for a specific step/node.  <a href="#a7b6725f4e543a5717af06a170b3ee411">More...</a><br /></td></tr>
<tr class="separator:a7b6725f4e543a5717af06a170b3ee411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545efea7aa7c0897d785ac0154bb3934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a545efea7aa7c0897d785ac0154bb3934">setState</a> (int, std::vector&lt; double &gt;)</td></tr>
<tr class="memdesc:a545efea7aa7c0897d785ac0154bb3934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state vector associated with a node with the specified ID.  <a href="#a545efea7aa7c0897d785ac0154bb3934">More...</a><br /></td></tr>
<tr class="separator:a545efea7aa7c0897d785ac0154bb3934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765f9ee99f0db3fa0569b5d8f23c17cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a765f9ee99f0db3fa0569b5d8f23c17cf">setStateByIx</a> (int, std::vector&lt; double &gt;)</td></tr>
<tr class="memdesc:a765f9ee99f0db3fa0569b5d8f23c17cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state vector for a specific node.  <a href="#a765f9ee99f0db3fa0569b5d8f23c17cf">More...</a><br /></td></tr>
<tr class="separator:a765f9ee99f0db3fa0569b5d8f23c17cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9139a5b3ca9ffe562613ebbb037a3998"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a9139a5b3ca9ffe562613ebbb037a3998">setSTMByIx</a> (int, <a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>)</td></tr>
<tr class="memdesc:a9139a5b3ca9ffe562613ebbb037a3998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the STM for a specific step/node.  <a href="#a9139a5b3ca9ffe562613ebbb037a3998">More...</a><br /></td></tr>
<tr class="separator:a9139a5b3ca9ffe562613ebbb037a3998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82249c5ec1c86c17dc82373a33beb6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ad82249c5ec1c86c17dc82373a33beb6e">setSTM</a> (int, <a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>)</td></tr>
<tr class="memdesc:ad82249c5ec1c86c17dc82373a33beb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the STM associated with a segment with the specified ID.  <a href="#ad82249c5ec1c86c17dc82373a33beb6e">More...</a><br /></td></tr>
<tr class="separator:ad82249c5ec1c86c17dc82373a33beb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a4c7d4b7fb10572fe8bfe0fe9d534b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a02a4c7d4b7fb10572fe8bfe0fe9d534b">setTol</a> (double)</td></tr>
<tr class="memdesc:a02a4c7d4b7fb10572fe8bfe0fe9d534b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the computational tolerance for this data object.  <a href="#a02a4c7d4b7fb10572fe8bfe0fe9d534b">More...</a><br /></td></tr>
<tr class="separator:a02a4c7d4b7fb10572fe8bfe0fe9d534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility Functions</div></td></tr>
<tr class="memitem:ae0d2ba61cebb1e2c86e643a8a3938e16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0d2ba61cebb1e2c86e643a8a3938e16"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ae0d2ba61cebb1e2c86e643a8a3938e16">reset</a> ()</td></tr>
<tr class="memdesc:ae0d2ba61cebb1e2c86e643a8a3938e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all data from this object and reset all parameters. <br /></td></tr>
<tr class="separator:ae0d2ba61cebb1e2c86e643a8a3938e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13aee6f8eee7cdafd5db4cf3a15b7206"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13aee6f8eee7cdafd5db4cf3a15b7206"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a13aee6f8eee7cdafd5db4cf3a15b7206">printInChrono</a> () const </td></tr>
<tr class="memdesc:a13aee6f8eee7cdafd5db4cf3a15b7206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a ASCII graphic of the arcset in chronological order. <br /></td></tr>
<tr class="separator:a13aee6f8eee7cdafd5db4cf3a15b7206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68ebceb16264509fde5211475615b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c68ebceb16264509fde5211475615b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a3c68ebceb16264509fde5211475615b1">printNodeIDMap</a> () const </td></tr>
<tr class="memdesc:a3c68ebceb16264509fde5211475615b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print nodeIDMap to standard output. <br /></td></tr>
<tr class="separator:a3c68ebceb16264509fde5211475615b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa744798e7237e626f6ec30a0760be224"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa744798e7237e626f6ec30a0760be224"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aa744798e7237e626f6ec30a0760be224">printSegIDMap</a> () const </td></tr>
<tr class="memdesc:aa744798e7237e626f6ec30a0760be224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print segIDMap to standard output. <br /></td></tr>
<tr class="separator:aa744798e7237e626f6ec30a0760be224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b22fc5498b81818eb547e787a295dbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b22fc5498b81818eb547e787a295dbe"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a0b22fc5498b81818eb547e787a295dbe">print</a> () const =0</td></tr>
<tr class="memdesc:a0b22fc5498b81818eb547e787a295dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a useful messages about the object. <br /></td></tr>
<tr class="separator:a0b22fc5498b81818eb547e787a295dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a950cf4bd7472ce8909bdeb1c8089ae2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a950cf4bd7472ce8909bdeb1c8089ae2c">copyMe</a> (const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> &amp;)</td></tr>
<tr class="memdesc:a950cf4bd7472ce8909bdeb1c8089ae2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy all data from the input arc data to this one.  <a href="#a950cf4bd7472ce8909bdeb1c8089ae2c">More...</a><br /></td></tr>
<tr class="separator:a950cf4bd7472ce8909bdeb1c8089ae2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0523e7de274190cd42208515154f63ef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classastrohelion_1_1_sys_data.html">SysData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a0523e7de274190cd42208515154f63ef">pSysData</a></td></tr>
<tr class="separator:a0523e7de274190cd42208515154f63ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e932915cd0f354291a292f6288ad1ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classastrohelion_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a4e932915cd0f354291a292f6288ad1ea">nodes</a> {}</td></tr>
<tr class="separator:a4e932915cd0f354291a292f6288ad1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50a772f7324c1692f112ac163f60f65"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ac50a772f7324c1692f112ac163f60f65">segs</a> {}</td></tr>
<tr class="separator:ac50a772f7324c1692f112ac163f60f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7a64ee5e93ffe8c561117f143cbd6d"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a8b7a64ee5e93ffe8c561117f143cbd6d">nodeIDMap</a> {}</td></tr>
<tr class="separator:a8b7a64ee5e93ffe8c561117f143cbd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1ae1c103b27ebd13b7395a632c162b"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#afd1ae1c103b27ebd13b7395a632c162b">segIDMap</a> {}</td></tr>
<tr class="separator:afd1ae1c103b27ebd13b7395a632c162b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20bc83881569d27294ce76b4b67fb0e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classastrohelion_1_1_constraint.html">Constraint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ac20bc83881569d27294ce76b4b67fb0e">cons</a> {}</td></tr>
<tr class="separator:ac20bc83881569d27294ce76b4b67fb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9102218463ab2b09966c91f9e7d83ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9102218463ab2b09966c91f9e7d83ba"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#af9102218463ab2b09966c91f9e7d83ba">tol</a> = 0</td></tr>
<tr class="memdesc:af9102218463ab2b09966c91f9e7d83ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance used to compute this data. <br /></td></tr>
<tr class="separator:af9102218463ab2b09966c91f9e7d83ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc232a671dbd58843cd447ffd382f0fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc232a671dbd58843cd447ffd382f0fc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#abc232a671dbd58843cd447ffd382f0fc">nextNodeID</a> = 0</td></tr>
<tr class="memdesc:abc232a671dbd58843cd447ffd382f0fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter that stores the next available node ID. <br /></td></tr>
<tr class="separator:abc232a671dbd58843cd447ffd382f0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab509893987f7768e18909209e753dc3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab509893987f7768e18909209e753dc3f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab509893987f7768e18909209e753dc3f">nextSegID</a> = 0</td></tr>
<tr class="memdesc:ab509893987f7768e18909209e753dc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A counter that stores the next available segment ID. <br /></td></tr>
<tr class="separator:ab509893987f7768e18909209e753dc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dc8f1e0500d638ada61873874a9ff7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94dc8f1e0500d638ada61873874a9ff7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a94dc8f1e0500d638ada61873874a9ff7">bInChronoOrder</a> = false</td></tr>
<tr class="memdesc:a94dc8f1e0500d638ada61873874a9ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the arcset is in chronological order. <br /></td></tr>
<tr class="separator:a94dc8f1e0500d638ada61873874a9ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Operators</h2></td></tr>
<tr class="memitem:a8fc2ff12dd2472686b82073fc96b7d44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a8fc2ff12dd2472686b82073fc96b7d44">operator=</a> (const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> &amp;)</td></tr>
<tr class="memdesc:a8fc2ff12dd2472686b82073fc96b7d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this object equal to another.  <a href="#a8fc2ff12dd2472686b82073fc96b7d44">More...</a><br /></td></tr>
<tr class="separator:a8fc2ff12dd2472686b82073fc96b7d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b0b4cdd57c4a2ecfb2a52b43b58497"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a75b0b4cdd57c4a2ecfb2a52b43b58497">sum</a> (const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *, const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *, <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *)</td></tr>
<tr class="memdesc:a75b0b4cdd57c4a2ecfb2a52b43b58497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum two arcset objects.  <a href="#a75b0b4cdd57c4a2ecfb2a52b43b58497">More...</a><br /></td></tr>
<tr class="separator:a75b0b4cdd57c4a2ecfb2a52b43b58497"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Analysis Functions</h2></td></tr>
<tr class="memitem:a7757b522992fce41efdfab407e13e90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a7757b522992fce41efdfab407e13e90c">addConstraint</a> (<a class="el" href="classastrohelion_1_1_constraint.html">Constraint</a>)</td></tr>
<tr class="memdesc:a7757b522992fce41efdfab407e13e90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a constraint to the arcset object.  <a href="#a7757b522992fce41efdfab407e13e90c">More...</a><br /></td></tr>
<tr class="separator:a7757b522992fce41efdfab407e13e90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e7f3a7f999cf67c0ff1ef54bfc359a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a18e7f3a7f999cf67c0ff1ef54bfc359a">addNode</a> (<a class="el" href="classastrohelion_1_1_node.html">Node</a>)</td></tr>
<tr class="memdesc:a18e7f3a7f999cf67c0ff1ef54bfc359a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node to this data object.  <a href="#a18e7f3a7f999cf67c0ff1ef54bfc359a">More...</a><br /></td></tr>
<tr class="separator:a18e7f3a7f999cf67c0ff1ef54bfc359a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30978e664f92ace8203b7c7501f3c03d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a30978e664f92ace8203b7c7501f3c03d">addSeg</a> (<a class="el" href="classastrohelion_1_1_segment.html">Segment</a>)</td></tr>
<tr class="memdesc:a30978e664f92ace8203b7c7501f3c03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a segment to the arcset object.  <a href="#a30978e664f92ace8203b7c7501f3c03d">More...</a><br /></td></tr>
<tr class="separator:a30978e664f92ace8203b7c7501f3c03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c63d09bb611d313e0f2f98d1f1a150"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a56c63d09bb611d313e0f2f98d1f1a150">appendSetAtNode</a> (const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *, int, int, double, <a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> *pNewSegLaw=nullptr)</td></tr>
<tr class="memdesc:a56c63d09bb611d313e0f2f98d1f1a150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an arcset object (i.e., a set of nodes and segments) to this one.  <a href="#a56c63d09bb611d313e0f2f98d1f1a150">More...</a><br /></td></tr>
<tr class="separator:a56c63d09bb611d313e0f2f98d1f1a150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81785d4f1f41ecab632a3b014b142f02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a81785d4f1f41ecab632a3b014b142f02">clearArcConstraints</a> ()</td></tr>
<tr class="memdesc:a81785d4f1f41ecab632a3b014b142f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all constraints from this arcset object.  <a href="#a81785d4f1f41ecab632a3b014b142f02">More...</a><br /></td></tr>
<tr class="separator:a81785d4f1f41ecab632a3b014b142f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f983b2efaff36d4d1edd0ff21b2e905"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f983b2efaff36d4d1edd0ff21b2e905"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a8f983b2efaff36d4d1edd0ff21b2e905">clearAllConstraints</a> ()</td></tr>
<tr class="memdesc:a8f983b2efaff36d4d1edd0ff21b2e905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove constraints from this arcset object as well as all its node and segment children. <br /></td></tr>
<tr class="separator:a8f983b2efaff36d4d1edd0ff21b2e905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ff6ec828923c1850b48fbf15e1ab8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aa9ff6ec828923c1850b48fbf15e1ab8d">concatArcset</a> (const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *)</td></tr>
<tr class="memdesc:aa9ff6ec828923c1850b48fbf15e1ab8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two arcset objects.  <a href="#aa9ff6ec828923c1850b48fbf15e1ab8d">More...</a><br /></td></tr>
<tr class="separator:aa9ff6ec828923c1850b48fbf15e1ab8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377ece1b15a10ddb58144ca0272be7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a377ece1b15a10ddb58144ca0272be7af">deleteNode</a> (int)</td></tr>
<tr class="memdesc:a377ece1b15a10ddb58144ca0272be7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the node with the specified ID.  <a href="#a377ece1b15a10ddb58144ca0272be7af">More...</a><br /></td></tr>
<tr class="separator:a377ece1b15a10ddb58144ca0272be7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70279f40c6f22accc37846cb3bf57c19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a70279f40c6f22accc37846cb3bf57c19">deleteNodeByIx</a> (int)</td></tr>
<tr class="memdesc:a70279f40c6f22accc37846cb3bf57c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a node at the specified index.  <a href="#a70279f40c6f22accc37846cb3bf57c19">More...</a><br /></td></tr>
<tr class="separator:a70279f40c6f22accc37846cb3bf57c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcacf1389e569d6588a230a7ca26a322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#adcacf1389e569d6588a230a7ca26a322">deleteSeg</a> (int)</td></tr>
<tr class="memdesc:adcacf1389e569d6588a230a7ca26a322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a segment with the specified ID.  <a href="#adcacf1389e569d6588a230a7ca26a322">More...</a><br /></td></tr>
<tr class="separator:adcacf1389e569d6588a230a7ca26a322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2f591140f4ac96e0811e71c2c2d134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a4b2f591140f4ac96e0811e71c2c2d134">deleteSegByIx</a> (int)</td></tr>
<tr class="memdesc:a4b2f591140f4ac96e0811e71c2c2d134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a segment at the specified index.  <a href="#a4b2f591140f4ac96e0811e71c2c2d134">More...</a><br /></td></tr>
<tr class="separator:a4b2f591140f4ac96e0811e71c2c2d134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a2e3f124a0fe971475fb3c55e35d7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a40a2e3f124a0fe971475fb3c55e35d7c">sortChrono</a> (bool force=false)</td></tr>
<tr class="memdesc:a40a2e3f124a0fe971475fb3c55e35d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rearrange the nodes and segments so that they are listed in chronological order in their storage arrays.  <a href="#a40a2e3f124a0fe971475fb3c55e35d7c">More...</a><br /></td></tr>
<tr class="separator:a40a2e3f124a0fe971475fb3c55e35d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef68a2edceb7a4d8a2b27f83b94c78b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a4ef68a2edceb7a4d8a2b27f83b94c78b">updateEpochs</a> (int, double)</td></tr>
<tr class="memdesc:a4ef68a2edceb7a4d8a2b27f83b94c78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the epochs of all nodes such that time is continuous.  <a href="#a4ef68a2edceb7a4d8a2b27f83b94c78b">More...</a><br /></td></tr>
<tr class="separator:a4ef68a2edceb7a4d8a2b27f83b94c78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83b5ba87b900936c6f828acda6ee6be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structastrohelion_1_1_arc_piece.html">ArcPiece</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#af83b5ba87b900936c6f828acda6ee6be">sortArcset</a> (int, std::vector&lt; <a class="el" href="structastrohelion_1_1_arc_piece.html">ArcPiece</a> &gt;) const </td></tr>
<tr class="memdesc:af83b5ba87b900936c6f828acda6ee6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the arcset into chronological order beginning at a specified node.  <a href="#af83b5ba87b900936c6f828acda6ee6be">More...</a><br /></td></tr>
<tr class="separator:af83b5ba87b900936c6f828acda6ee6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
File I/O</h2></td></tr>
<tr class="memitem:ae41abbe5f68daed8ae6f68135ff384cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ae41abbe5f68daed8ae6f68135ff384cc">readFromMat</a> (const char *filepath, std::vector&lt; <a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> * &gt; &amp;)=0</td></tr>
<tr class="memdesc:ae41abbe5f68daed8ae6f68135ff384cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the object from a Matlab binary file.  <a href="#ae41abbe5f68daed8ae6f68135ff384cc">More...</a><br /></td></tr>
<tr class="separator:ae41abbe5f68daed8ae6f68135ff384cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc576199290ea0baa914efe85c2841"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a44fc576199290ea0baa914efe85c2841">saveToMat</a> (const char *filepath, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>) const =0</td></tr>
<tr class="memdesc:a44fc576199290ea0baa914efe85c2841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves the object to a Matlab binary file.  <a href="#a44fc576199290ea0baa914efe85c2841">More...</a><br /></td></tr>
<tr class="separator:a44fc576199290ea0baa914efe85c2841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bb534b6186c55d99c2bba50a602fad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab5bb534b6186c55d99c2bba50a602fad">initNodesSegsFromMat</a> (mat_t *, const char *pStateVarName=VARNAME_NODESTATE)</td></tr>
<tr class="memdesc:ab5bb534b6186c55d99c2bba50a602fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the vectors of node and segment objects from a *.mat file.  <a href="#ab5bb534b6186c55d99c2bba50a602fad">More...</a><br /></td></tr>
<tr class="separator:ab5bb534b6186c55d99c2bba50a602fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87b6ab82eb6cf3ee230090db8be18cf"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aa87b6ab82eb6cf3ee230090db8be18cf">createVar_LinkTable</a> (const char *pVarName=VARNAME_LINKTABLE) const </td></tr>
<tr class="memdesc:aa87b6ab82eb6cf3ee230090db8be18cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the link table.  <a href="#aa87b6ab82eb6cf3ee230090db8be18cf">More...</a><br /></td></tr>
<tr class="separator:aa87b6ab82eb6cf3ee230090db8be18cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850f17927210d98bb2f32fe3f2665af9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a850f17927210d98bb2f32fe3f2665af9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>readVar_LinkTable</b> (matvar_t *)</td></tr>
<tr class="separator:a850f17927210d98bb2f32fe3f2665af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856c49b0a0a29f435142816000074c05"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a856c49b0a0a29f435142816000074c05">createVar_Constraints</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_CONSTRAINTS) const </td></tr>
<tr class="memdesc:a856c49b0a0a29f435142816000074c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the constraints.  <a href="#a856c49b0a0a29f435142816000074c05">More...</a><br /></td></tr>
<tr class="separator:a856c49b0a0a29f435142816000074c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b7fab931f7b2b6911881b273dd4c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a782b7fab931f7b2b6911881b273dd4c4">readVar_Constraints</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:a782b7fab931f7b2b6911881b273dd4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read constraints from a matio variable.  <a href="#a782b7fab931f7b2b6911881b273dd4c4">More...</a><br /></td></tr>
<tr class="separator:a782b7fab931f7b2b6911881b273dd4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca52cd23f13cbcd492a05efa0296ec5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#afca52cd23f13cbcd492a05efa0296ec5">readVar_NodeState</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:afca52cd23f13cbcd492a05efa0296ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read node states from a matio variable.  <a href="#afca52cd23f13cbcd492a05efa0296ec5">More...</a><br /></td></tr>
<tr class="separator:afca52cd23f13cbcd492a05efa0296ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08ca2b162b0eb12bb36d3624c90de7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a2e08ca2b162b0eb12bb36d3624c90de7">readVar_NodeEpoch</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:a2e08ca2b162b0eb12bb36d3624c90de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read node epochs from a matio variable.  <a href="#a2e08ca2b162b0eb12bb36d3624c90de7">More...</a><br /></td></tr>
<tr class="separator:a2e08ca2b162b0eb12bb36d3624c90de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022b00fc000c2b8096737dbbbd076d71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a022b00fc000c2b8096737dbbbd076d71">readVar_NodeStateDeriv</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:a022b00fc000c2b8096737dbbbd076d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read node state derivatives from a matio variable.  <a href="#a022b00fc000c2b8096737dbbbd076d71">More...</a><br /></td></tr>
<tr class="separator:a022b00fc000c2b8096737dbbbd076d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad785bcffba15d35ed084116ef81c650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aad785bcffba15d35ed084116ef81c650">readVar_NodeExtraParam</a> (matvar_t *, std::string, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:aad785bcffba15d35ed084116ef81c650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read node extra parameter data from a matio variable.  <a href="#aad785bcffba15d35ed084116ef81c650">More...</a><br /></td></tr>
<tr class="separator:aad785bcffba15d35ed084116ef81c650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b6d8e34094dfcf30a64cffd88cc6c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a46b6d8e34094dfcf30a64cffd88cc6c3">readVar_NodeExtraParamVec</a> (matvar_t *, std::string, size_t, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:a46b6d8e34094dfcf30a64cffd88cc6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read node extra parameter vectors from a matio variable.  <a href="#a46b6d8e34094dfcf30a64cffd88cc6c3">More...</a><br /></td></tr>
<tr class="separator:a46b6d8e34094dfcf30a64cffd88cc6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae41c6eb8584239a9836e2c39182aa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aaae41c6eb8584239a9836e2c39182aa9">readVar_NodeCtrl</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:aaae41c6eb8584239a9836e2c39182aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read node control data from a matio variable.  <a href="#aaae41c6eb8584239a9836e2c39182aa9">More...</a><br /></td></tr>
<tr class="separator:aaae41c6eb8584239a9836e2c39182aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2754c59f053f7c2549cc9488510a8e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab2754c59f053f7c2549cc9488510a8e0">readVar_SegState</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:ab2754c59f053f7c2549cc9488510a8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read segment state data from a matio variable.  <a href="#ab2754c59f053f7c2549cc9488510a8e0">More...</a><br /></td></tr>
<tr class="separator:ab2754c59f053f7c2549cc9488510a8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9465e64c9ac0cbe74f8046610c4395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a5d9465e64c9ac0cbe74f8046610c4395">readVar_SegTime</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:a5d9465e64c9ac0cbe74f8046610c4395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read segment time data from a matio variable.  <a href="#a5d9465e64c9ac0cbe74f8046610c4395">More...</a><br /></td></tr>
<tr class="separator:a5d9465e64c9ac0cbe74f8046610c4395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29eb48b323388a0856dfe51c5a0faa62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a29eb48b323388a0856dfe51c5a0faa62">readVar_SegTOF</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:a29eb48b323388a0856dfe51c5a0faa62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read segment TOF data from a matio variable.  <a href="#a29eb48b323388a0856dfe51c5a0faa62">More...</a><br /></td></tr>
<tr class="separator:a29eb48b323388a0856dfe51c5a0faa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab490ea54a4faa9092bdc9b1c5f6fb5f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab490ea54a4faa9092bdc9b1c5f6fb5f2">readVar_SegSTM</a> (matvar_t *, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:ab490ea54a4faa9092bdc9b1c5f6fb5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read segment STM data from a matio variable.  <a href="#ab490ea54a4faa9092bdc9b1c5f6fb5f2">More...</a><br /></td></tr>
<tr class="separator:ab490ea54a4faa9092bdc9b1c5f6fb5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9769dd0cb4a0d0358d64961a5209bbdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a9769dd0cb4a0d0358d64961a5209bbdf">readVar_SegCtrlLaw</a> (matvar_t *, std::vector&lt; <a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> * &gt; &amp;, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>)</td></tr>
<tr class="memdesc:a9769dd0cb4a0d0358d64961a5209bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read segment control law data from a matio variable.  <a href="#a9769dd0cb4a0d0358d64961a5209bbdf">More...</a><br /></td></tr>
<tr class="separator:a9769dd0cb4a0d0358d64961a5209bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7306482b7c8f71b8d98dce1b0248c941"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a7306482b7c8f71b8d98dce1b0248c941">createVar_NodeCtrl</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_NODECTRL) const </td></tr>
<tr class="memdesc:a7306482b7c8f71b8d98dce1b0248c941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the node control data.  <a href="#a7306482b7c8f71b8d98dce1b0248c941">More...</a><br /></td></tr>
<tr class="separator:a7306482b7c8f71b8d98dce1b0248c941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6447652d5645d2182e7be71595ca67d"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#af6447652d5645d2182e7be71595ca67d">createVar_NodeExtraParam</a> (std::string, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>, const char *) const </td></tr>
<tr class="memdesc:af6447652d5645d2182e7be71595ca67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the scalar node extra parameters.  <a href="#af6447652d5645d2182e7be71595ca67d">More...</a><br /></td></tr>
<tr class="separator:af6447652d5645d2182e7be71595ca67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82dba0633e1802b871544e7da9dd1b"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a0f82dba0633e1802b871544e7da9dd1b">createVar_NodeExtraParamVec</a> (std::string, size_t, <a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp, const char *) const </td></tr>
<tr class="memdesc:a0f82dba0633e1802b871544e7da9dd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the vector node extra parameters.  <a href="#a0f82dba0633e1802b871544e7da9dd1b">More...</a><br /></td></tr>
<tr class="separator:a0f82dba0633e1802b871544e7da9dd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41a119985659208a36a13d8b5ac6bf7"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#ab41a119985659208a36a13d8b5ac6bf7">createVar_NodeState</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_NODESTATE) const </td></tr>
<tr class="memdesc:ab41a119985659208a36a13d8b5ac6bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the node states.  <a href="#ab41a119985659208a36a13d8b5ac6bf7">More...</a><br /></td></tr>
<tr class="separator:ab41a119985659208a36a13d8b5ac6bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183e2df11aa223f940a9b150f5909109"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a183e2df11aa223f940a9b150f5909109">createVar_NodeEpoch</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_NODETIME) const </td></tr>
<tr class="memdesc:a183e2df11aa223f940a9b150f5909109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the node epoch times.  <a href="#a183e2df11aa223f940a9b150f5909109">More...</a><br /></td></tr>
<tr class="separator:a183e2df11aa223f940a9b150f5909109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf65b5011851276672f355cbf144413d"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#aaf65b5011851276672f355cbf144413d">createVar_NodeStateDeriv</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_STATE_DERIV) const </td></tr>
<tr class="memdesc:aaf65b5011851276672f355cbf144413d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the node state derivatives.  <a href="#aaf65b5011851276672f355cbf144413d">More...</a><br /></td></tr>
<tr class="separator:aaf65b5011851276672f355cbf144413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8008cd70459f19cf91ae9aaf8f6bc8"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a6a8008cd70459f19cf91ae9aaf8f6bc8">createVar_SegCtrlLaw</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_SEGCTRL) const </td></tr>
<tr class="memdesc:a6a8008cd70459f19cf91ae9aaf8f6bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the segment control law data.  <a href="#a6a8008cd70459f19cf91ae9aaf8f6bc8">More...</a><br /></td></tr>
<tr class="separator:a6a8008cd70459f19cf91ae9aaf8f6bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe289bd2ab250cea2962f1e35445731"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#adbe289bd2ab250cea2962f1e35445731">createVar_SegState</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_SEGSTATE) const </td></tr>
<tr class="memdesc:adbe289bd2ab250cea2962f1e35445731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the segment states.  <a href="#adbe289bd2ab250cea2962f1e35445731">More...</a><br /></td></tr>
<tr class="separator:adbe289bd2ab250cea2962f1e35445731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e806ec45019ccf0dd77cccf34e9f18"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a65e806ec45019ccf0dd77cccf34e9f18">createVar_SegSTM</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_STM) const </td></tr>
<tr class="memdesc:a65e806ec45019ccf0dd77cccf34e9f18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the segment STMs.  <a href="#a65e806ec45019ccf0dd77cccf34e9f18">More...</a><br /></td></tr>
<tr class="separator:a65e806ec45019ccf0dd77cccf34e9f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7ab2b11f5b4ea3eb5924367d728a2b"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#afe7ab2b11f5b4ea3eb5924367d728a2b">createVar_SegTime</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_SEGTIME) const </td></tr>
<tr class="memdesc:afe7ab2b11f5b4ea3eb5924367d728a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the segment times.  <a href="#afe7ab2b11f5b4ea3eb5924367d728a2b">More...</a><br /></td></tr>
<tr class="separator:afe7ab2b11f5b4ea3eb5924367d728a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2178a6b85ff7ee7e335946eb7a8acde2"><td class="memItemLeft" align="right" valign="top">matvar_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classastrohelion_1_1_base_arcset.html#a2178a6b85ff7ee7e335946eb7a8acde2">createVar_SegTOF</a> (<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a> saveTp=<a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a>, const char *pVarName=VARNAME_TOF) const </td></tr>
<tr class="memdesc:a2178a6b85ff7ee7e335946eb7a8acde2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matio variable for the segment times-of-flight.  <a href="#a2178a6b85ff7ee7e335946eb7a8acde2">More...</a><br /></td></tr>
<tr class="separator:a2178a6b85ff7ee7e335946eb7a8acde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract class that provides the framework for trajectories and nodesets. </p>
<p>The arcset object specifies default and mandatory behaviors for all derivative classes (i.e. <a class="el" href="classastrohelion_1_1_arcset.html" title="Extends BaseArcset in a few areas. ">Arcset</a> and <a class="el" href="classastrohelion_1_1_arcset.html" title="Extends BaseArcset in a few areas. ">Arcset</a>). All variables and data for an arc or one of its derivative classes are declared and stored here; in other words, no derivative classes declare class-specific data objects. This architecture has been chosen to facilitate easy casting between model-specific derivative classes with the added bonus of being able to cast easily between, say, a trajectory and a nodeset.</p>
<p>This class contains all information about any trajectory or nodeset in a few objects:</p><ul>
<li>steps - a vector of tpat_arc_step objects, each of which contains information about the state, acceleration, STM, any any other parameter values at one single step</li>
<li>sysData - a pointer to a system data object that describes the system this arc has been generated in</li>
<li>numExtraParam and extraParamRowSize describe the number of extra parameters and the number of elements in each parameter; this various for different dynamical model-specific derivative classes</li>
<li>tol - The maximum numerical tolerance with which the data in this object has been computed</li>
</ul>
<p>The following behavior is mandatory for all derivative classes:</p><ul>
<li>Ability to add two arcs together via <a class="el" href="namespaceastrohelion.html#a1542c9b763e98a3117037bf374fa3369" title="Combine two arcsets. ">operator +()</a></li>
<li>Ability to save to a matlab file via <a class="el" href="classastrohelion_1_1_base_arcset.html#a44fc576199290ea0baa914efe85c2841" title="Saves the object to a Matlab binary file. ">saveToMat()</a></li>
<li>Ability to display a textual representation of the object via <a class="el" href="classastrohelion_1_1_base_arcset.html#a0b22fc5498b81818eb547e787a295dbe" title="Displays a useful messages about the object. ">print()</a></li>
</ul>
<p>Additionally, the following behavior is defined for all derivative classes, though they may override the default:</p><ul>
<li>Assignment operator</li>
<li>Access to position and velocity values at each step via <a class="el" href="classastrohelion_1_1_base_arcset.html#ad644d2e0a0438d4f8254916cf3fc08c4" title="Retrieve the state vector associated with a node with the specified ID. ">getState()</a></li>
<li>Access to acceleration values at each step via <a class="el" href="classastrohelion_1_1_base_arcset.html#a21b1d7ae815f2e956dae57d13cc82ad5" title="Retrieve the state derivative vector associated with a node with the specified ID. ">getStateDeriv()</a></li>
<li>Access to any extra parameters that evolve each step via getExtraParam()</li>
<li>Access to the STM at each step via <a class="el" href="classastrohelion_1_1_base_arcset.html#ab556be1b6fce4637ee8589d5ba5f92df" title="Retrieve the STM associated with a segment with the specified ID. ">getSTM()</a></li>
<li>Access to individual step objects via getStep()</li>
<li>Access to the system data object pointer that describes the system this arc was integrated in</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Andrew Cox </dd></dl>
<dl class="section version"><dt>Version</dt><dd>April 28, 2016 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>GNU GPL v3.0 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac06ebd04201c41361ba88f1520c29831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">astrohelion::BaseArcset::BaseArcset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_sys_data.html">SysData</a> *&#160;</td>
          <td class="paramname"><em>sys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor (requires system data object) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sys</td><td>a pointer to a system data object that describes the system this trajectory is integrated in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c51a6432f01a36b9777447d699d5854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">astrohelion::BaseArcset::BaseArcset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>an arcset reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7757b522992fce41efdfab407e13e90c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::addConstraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classastrohelion_1_1_constraint.html">Constraint</a>&#160;</td>
          <td class="paramname"><em>con</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a constraint to the arcset object. </p>
<p>The constraint application type determines whether the constraint is applied to a node, segment, or the arc as a whole.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">con</td><td>the constraint </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceastrohelion.html#a61e2cd687fa203fcd13228e2c8f5c438" title="Describes how a constraint is applied, i.e., what type of object is controlled by the constraint...">ConstraintApp_tp</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if node or segment ID is out of bounds, or if the constraint application type is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18e7f3a7f999cf67c0ff1ef54bfc359a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::BaseArcset::addNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classastrohelion_1_1_node.html">Node</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node to this data object. </p>
<p>A unique key is assigned to the node when it is added. Any links the input node has are cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the node to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID assigned to the node </dd></dl>

</div>
</div>
<a class="anchor" id="a30978e664f92ace8203b7c7501f3c03d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::BaseArcset::addSeg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a segment to the arcset object. </p>
<p>Besides adding the segment object to the storage vector, this function updates the nodes associated with the origin and terminus of the segment so they contain the proper links. Additionally, the function checks to make sure time flows in one direction only and that parallel structures are not created (i.e., two branches extend from one node in same time direction).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The segment to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of the segment </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if adding the segment will result in a time direction collision or a parallel structure. <a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a> is also thrown if the segment is linked to a non-existant node other than the placeholder <a class="el" href="classastrohelion_1_1_linkable.html#a0a0578810f652b6daffb5251e1fd84a5" title="Reserved ID value. ">Linkable::INVALID_ID</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56c63d09bb611d313e0f2f98d1f1a150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::BaseArcset::appendSetAtNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *&#160;</td>
          <td class="paramname"><em>pArcsetIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>appendNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> *&#160;</td>
          <td class="paramname"><em>pNewSegLaw</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append an arcset object (i.e., a set of nodes and segments) to this one. </p>
<p>The epochs associated with the nodes in this arcset are left unchanged and the epochs of the appended set are updated to be continuous</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pArcsetIn</td><td>a pointer to the arcset object that will be appended to this object </td></tr>
    <tr><td class="paramname">localNodeID</td><td>the ID of the node in <em>this</em> arcset object that <code>pArcsetIn</code> will be linked to </td></tr>
    <tr><td class="paramname">appendNodeID</td><td>the ID of the node in <code>pArcsetIn</code> to link from </td></tr>
    <tr><td class="paramname">tof</td><td>time-of-flight between appendNodeID to localNodeID; when this value is nonzero, an artificial segment is constructed two link the two arcsets. If <code>tof</code> is zero, then one of the nodes is deleted. If the node at <code>localNodeID</code> is an origin node, then the node at <code>appendNodeID</code> is deleted. If the local node is not an origin, then it is deleted instead. The segment left without a terminus is then connected to the remaining node. </td></tr>
    <tr><td class="paramname">pNewSegLaw</td><td>pointer to a control law that is applied to the artificial segment created if <code>tof</code> is not zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ID of a new segment that links the old and new arcset objects </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the two arcset objects have different system data objects </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if either ID is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if one or both of the identifies nodes does not have a free link slot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cfdae6510479237fe18dfb11aea1c8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; astrohelion::Core::bIsInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check to see if the core is initialized. </p>
<p>This function wraps a static boolean object to avoid multiple instances of the variable in different translation units </p><dl class="section return"><dt>Returns</dt><dd>whether or not the core is initialized </dd></dl>

</div>
</div>
<a class="anchor" id="a81785d4f1f41ecab632a3b014b142f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::clearArcConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all constraints from this arcset object. </p>
<p>Note that this does not affect any constraints placed on individual nodes or segments </p>

</div>
</div>
<a class="anchor" id="aa9ff6ec828923c1850b48fbf15e1ab8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; astrohelion::BaseArcset::concatArcset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *&#160;</td>
          <td class="paramname"><em>pSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two arcset objects. </p>
<p>The nodes, segments and constraints are copied from one arcset to another without creating or deleting any nodes or segments; i.e., the arcset object will include two independent "flows" without a segment to connect them. To construct a continuous "flow", see <a class="el" href="classastrohelion_1_1_base_arcset.html#a56c63d09bb611d313e0f2f98d1f1a150" title="Append an arcset object (i.e., a set of nodes and segments) to this one. ">appendSetAtNode()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSet</td><td>pointer to an arcset object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a map relating the nodeIDs in <code>pSet</code> to the new IDs of the same nodes in this object; the index of the vector is the old node ID and the value is the new node ID. If a node does not exist for one of the old ID values, a new value equivalent to <code><a class="el" href="classastrohelion_1_1_linkable.html#a0a0578810f652b6daffb5251e1fd84a5" title="Reserved ID value. ">Linkable::INVALID_ID</a></code> is stored in the associated vector element.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the input arcset does not have the same system data object as this one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classastrohelion_1_1_base_arcset.html#a56c63d09bb611d313e0f2f98d1f1a150" title="Append an arcset object (i.e., a set of nodes and segments) to this one. ">appendSetAtNode()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a950cf4bd7472ce8909bdeb1c8089ae2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::copyMe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy all data from the input arc data to this one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>an arc data object reference </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a856c49b0a0a29f435142816000074c05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_Constraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_CONSTRAINTS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the constraints. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="aa87b6ab82eb6cf3ee230090db8be18cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_LinkTable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_LINKTABLE</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the link table. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="a7306482b7c8f71b8d98dce1b0248c941"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_NodeCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_NODECTRL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the node control data. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="a183e2df11aa223f940a9b150f5909109"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_NodeEpoch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_NODETIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the node epoch times. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="af6447652d5645d2182e7be71595ca67d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_NodeExtraParam </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>varKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the scalar node extra parameters. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varKey</td><td>the unique key (i.e., name) of the scalar paremeter </td></tr>
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="a0f82dba0633e1802b871544e7da9dd1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_NodeExtraParamVec </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>varKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the vector node extra parameters. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">varKey</td><td>the key (i.e., the name) of the vector parameter </td></tr>
    <tr><td class="paramname">len</td><td>number of elements in the extra parameter vector </td></tr>
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="ab41a119985659208a36a13d8b5ac6bf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_NodeState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_NODESTATE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the node states. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="aaf65b5011851276672f355cbf144413d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_NodeStateDeriv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_STATE_DERIV</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the node state derivatives. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="a6a8008cd70459f19cf91ae9aaf8f6bc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_SegCtrlLaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_SEGCTRL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the segment control law data. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="adbe289bd2ab250cea2962f1e35445731"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_SegState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_SEGSTATE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the segment states. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="a65e806ec45019ccf0dd77cccf34e9f18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_SegSTM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_STM</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the segment STMs. </p>
<p>The STM is copied from each segment state vector, thus, the STM represents the evolution of each individual segment regardless of whether or not the arcset has been set to store cumulative STMs via setSTM_cumulative().</p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="afe7ab2b11f5b4ea3eb5924367d728a2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_SegTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_SEGTIME</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the segment times. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="a2178a6b85ff7ee7e335946eb7a8acde2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matvar_t * astrohelion::BaseArcset::createVar_SegTOF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_TOF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a matio variable for the segment times-of-flight. </p>
<p>The data is copied into a matvar_t pointer, which is allocated on the stack</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveTp</td><td>describes how much data to save </td></tr>
    <tr><td class="paramname">pVarName</td><td>variable name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the matio variable (must be freed by MatVar_Free()) </dd></dl>

</div>
</div>
<a class="anchor" id="a377ece1b15a10ddb58144ca0272be7af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::deleteNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the node with the specified ID. </p>
<p>In addition to deleting the desired node, the arcset object is "healed" so that time continuity is maintained. In the case of a linear-time set, the two segments on either side of the deleted node are combined. If the deleted node was the origin of two segments, they are still combined, but subject to a few extra conditions. First, if one of the segments connects to another segment and, therefore, doesn't link to another node, then the terminus of the other segment must be used. If both segments that originate from the deleted node terminate at other segments, an exception is thrown rather than attempting to step through mulitple segment links to identify the superposition of all the segments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the node to delete; if the ID is out of range, an exception is thrown. If the ID is in range but doesn't represent an actual node, no action is taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>when:<ul>
<li>The ID is out of bounds</li>
<li>The ID is in bounds but the associated node has been deleted (no longer exists)</li>
<li>Deleting the node will result in multiple segment interfaces; these must be created more explicitely by the user and will not be created automatically by this function. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70279f40c6f22accc37846cb3bf57c19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::deleteNodeByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a node at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>index of the node in the nodes vector. If ix &lt; 0, it will count backward from the end of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcacf1389e569d6588a230a7ca26a322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::deleteSeg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a segment with the specified ID. </p>
<p>Additionally, any nodes linked to the specified segment are updated so that their link arrays no longer include a relationship with the soon-to-be deceased segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The ID of the segment to delete. If the ID is out of range, an exception is thrown. If the ID is in range but doesn't represent an existing segment, no deletion is made </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b2f591140f4ac96e0811e71c2c2d134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::deleteSegByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a segment at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>index of the segment in the nodes vector. If ix &lt; 0, it will count backward from the end of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a459186fb23b639d6f7925deae21a4a55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classastrohelion_1_1_constraint.html">Constraint</a> &gt; astrohelion::BaseArcset::getAllConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a vector containing all the constraints applied to the arcset, nodes, and segments. </p>
<p>This vector DOES include constraints placed on individual nodes and segments </p><dl class="section return"><dt>Returns</dt><dd>a vector containing all the constraints applied to the arcset, nodes, and segments </dd></dl>

</div>
</div>
<a class="anchor" id="a014401d1bd70ff3652271769ef1be598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classastrohelion_1_1_constraint.html">Constraint</a> &gt; astrohelion::BaseArcset::getArcConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a vector containing all the constraints applied to this arcset object. </p>
<p>This vector does not include constraints placed on individual nodes or segments. </p><dl class="section return"><dt>Returns</dt><dd>a vector containing all the constraints applied to this arcset object. </dd></dl>

</div>
</div>
<a class="anchor" id="afd55faf6c1bb134d0269de20bc68b57a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structastrohelion_1_1_arc_piece.html">ArcPiece</a> &gt; astrohelion::BaseArcset::getChronoOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine what order to place the nodes and segments of this object into to achieve a chronological progression in forward time. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="structastrohelion_1_1_arc_piece.html" title="A structure used to represent nodes and segments. ">ArcPiece</a> objects that represent the chronological order of the nodes and segments </dd></dl>

</div>
</div>
<a class="anchor" id="ab0a43ec879c5c350281f0242ad64835a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::BaseArcset::getCoord </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a vector of one coordinate for all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>the index of the state coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the specified coordinate for all nodes (not necessarily in chronological order) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24a82f9aca02c373dc08b1dabc84ccd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> * astrohelion::BaseArcset::getCtrlLawByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a pointer to the control law for a segment at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>Index of the segment within the storage vector. If ix &lt; 0, it will count backwards from the end of the storage vector. s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>control law pointer for the specified segment </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if ix is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50af3f821077ee2de2c9f290f4faddd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> * astrohelion::BaseArcset::getCtrlLawByIx_const </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a constant pointer to the control law for a segment at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>Index of the segment within the storage vector. If ix &lt; 0, it will count backwards from the end of the storage vector. s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constant control law pointer for the specified segment </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if ix is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a6f06a5c4c7d6f88207ecb715f0f375"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::BaseArcset::getEpoch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the epoch associated with a node with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the epoch </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the node with the specified ID is not located in the nodeIDMap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc1975e8ad1906e4a99edb7e6f5b88f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::BaseArcset::getEpochByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the epoch of a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>the node index within the <code>nodes</code> storage array; This value is not necessarily the same as the unique ID assigned to the node when it was added to the arcset object. If <code>n</code> is negative, this index will cound backwards from the end of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The epoch associated with the specified node </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f9aa231608a7b0b6e1e77a6127ceb17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::BaseArcset::getEpochs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a vector of all epoch values for the nodes. </p>
<p>Epochs are returned in the order corresponding to the nodes vector; to ensure chronological order, it is best to sort the arcset first. </p><dl class="section return"><dt>Returns</dt><dd>A vector with the epochs for all the nodes </dd></dl>

</div>
</div>
<a class="anchor" id="a190825543c9210190a8fedc9fb790ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::BaseArcset::getExtraParamByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a set of extra parameters for the specified node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the node index within the <code>nodes</code> storage array; This value is not necessarily the same as the unique ID assigned to the node when it was added to the arcset object. If <code>n</code> is negative, this index will cound backwards from the end of the array.</td></tr>
    <tr><td class="paramname">key</td><td>string that identifies the extra parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the extra parameter at the specified step and index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>n</code> is out of bounds or if the key is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74e27fd3b9e892c6a6bba0dde9e24c48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::BaseArcset::getExtraParamVecByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a set of extra parameters for the specified node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>node index within the <code>nodes</code> storage array; This value is not necessarily the same as the unique ID assigned to the node when it was added to the arcset object. If <code>n</code> is negative, this index will cound backwards from the end of the array. </td></tr>
    <tr><td class="paramname">key</td><td>string that identifies the extra parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of extra parameters </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the index is out of bounds or if the key is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf13d19c108c337b7c45d00544cca90a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::BaseArcset::getNextNodeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of the ID that will be assigned to the next node added to this arcset object. </p>
<dl class="section return"><dt>Returns</dt><dd>the next node ID </dd></dl>

</div>
</div>
<a class="anchor" id="a8c83f400ec6308753424eb22f1182443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::BaseArcset::getNextSegID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the value of the ID that will be assigned to the next segment added to this arcset object. </p>
<dl class="section return"><dt>Returns</dt><dd>the next segment ID </dd></dl>

</div>
</div>
<a class="anchor" id="a268ad635b718e419d7d11757854d83e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_node.html">Node</a> astrohelion::BaseArcset::getNode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the desired node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node located with the specified ID </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds or if no node exists with the specified ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9e6a1b8bcb05ddb858b41166ca6b684"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_node.html">Node</a> astrohelion::BaseArcset::getNodeByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a node based on its index in the storage array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>The index of the node; if <code>ix</code> is negative, the index will count backwards from the end of the storage array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a node at the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae75866ed5ba5c199db71c555f7ea9445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::BaseArcset::getNodeIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the index of a specific node within the node storage vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>node ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the node with the specified ID within the storage vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4c03c3694d6dab55eb7db18eb56512b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_node.html">Node</a> &amp; astrohelion::BaseArcset::getNodeRef </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the desired node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node located with the specified ID </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds or if no node exists with the specified ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bf2eea0d243cd3b0aadae9f3c5a2d13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classastrohelion_1_1_node.html">Node</a> &amp; astrohelion::BaseArcset::getNodeRef_const </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the desired node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node located with the specified ID </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds or if no node exists with the specified ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad21ca59da053746b01b80346897c304"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_node.html">Node</a> &amp; astrohelion::BaseArcset::getNodeRefByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to a node based on its index in the storage array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>The index of the node; if <code>ix</code> is negative, the index will count backwards from the end of the storage array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a node at the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a088f0aa4d9f024c237b984f38e9f76c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classastrohelion_1_1_node.html">Node</a> &amp; astrohelion::BaseArcset::getNodeRefByIx_const </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to a node based on its index in the storage array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>The index of the node; if <code>ix</code> is negative, the index will count backwards from the end of the storage array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a node at the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab815c98024400676fc79b40c1a7cfa30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int astrohelion::BaseArcset::getNumCons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the total number of constraints contained by all nodes, segments, and the arcset object itself. </p>
<dl class="section return"><dt>Returns</dt><dd>the total number of constraints applied to this object and its children </dd></dl>

</div>
</div>
<a class="anchor" id="a210919d8b4ba59f07644c73962f4f058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int astrohelion::BaseArcset::getNumNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes </dd></dl>

</div>
</div>
<a class="anchor" id="ab58515de87209d9c0b5b0a6f6f7a8104"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int astrohelion::BaseArcset::getNumSegs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of segments. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of segments </dd></dl>

</div>
</div>
<a class="anchor" id="a9135d17bd10f1cf03ea6ccaf75f8a4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a> astrohelion::BaseArcset::getSeg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the desired node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node located with the specified ID </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds or if no segment exists with the specified ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a547c71fcc8d59f6d9e631b1bfb3a3f95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a> astrohelion::BaseArcset::getSegByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a segment based on its index in the storage array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>The index of the segment; if <code>ix</code> is negative, the index will count backwards from the end of the storage array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a segment at the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ffb92a2c0d733d5958f30cb93d41397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::BaseArcset::getSegIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the index of a specific node within the node storage vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>node ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the node with the specified ID within the storage vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accb66923aa7a826982aac2bfe5d197c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &amp; astrohelion::BaseArcset::getSegRef </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to a specific segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the desired segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the segment located with the specified ID </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds or if no segment exists with the specified ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8703ec3145e2d9ea684d8c41ee0c602c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &amp; astrohelion::BaseArcset::getSegRef_const </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to a specific segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the desired segment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the segment located with the specified ID </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds or if no segment exists with the specified ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86e89d328c7331cd6125b3d1c919ad50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &amp; astrohelion::BaseArcset::getSegRefByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to a segment based on its index in the storage array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>The index of the segment; if <code>ix</code> is negative, the index will count backwards from the end of the storage array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a segment at the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a582e0a4b759f776e971313156e7c5aef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classastrohelion_1_1_segment.html">Segment</a> &amp; astrohelion::BaseArcset::getSegRefByIx_const </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a reference to a segment based on its index in the storage array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>The index of the segment; if <code>ix</code> is negative, the index will count backwards from the end of the storage array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to a segment at the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad644d2e0a0438d4f8254916cf3fc08c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::BaseArcset::getState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the state vector associated with a node with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the node with the specified ID is not located in the nodeIDMap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07886ce3596a1506a12ff88d7b6d9faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::BaseArcset::getStateByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a position-velocity state on the arc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>the node index within the <code>nodes</code> storage array; This value is not necessarily the same as the unique ID assigned to the node when it was added to the arcset object. If <code>n</code> is negative, this index will cound backwards from the end of the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state associated with the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21b1d7ae815f2e956dae57d13cc82ad5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::BaseArcset::getStateDeriv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the state derivative vector associated with a node with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the acceleration vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the node with the specified ID is not located in the nodeIDMap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91d83e52bdd9bce7b98952229d34cd3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::BaseArcset::getStateDerivByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an acceleration on the arc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>the step index. If it is negative, the index will count backwards from the end of the arc (e.g. ix = -1 will return the last acceleration) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the acceleration associated with the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab556be1b6fce4637ee8589d5ba5f92df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a> astrohelion::BaseArcset::getSTM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the STM associated with a segment with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the STM </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the segment with the specified ID is not located in the segIDMap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a388f1be5eb8fe2a06aaba4e9da9352ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a> astrohelion::BaseArcset::getSTMByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve an STM associated with a segment with the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>the segment index. If it is negative, the index will count backwards from the end of the <code>segs</code> storage array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the STM associated with the specified index </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42b82ff1647ee0c1c29ef443ba0d35b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::BaseArcset::getSTMElementsByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the elements of the STM at the specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>ix the segment index. If it is negative, the index will count backwards from the end of the <code>segs</code> storage array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The STM elements, in row-major order </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52e822e63473e652fe9e567a9adbf5a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classastrohelion_1_1_sys_data.html">SysData</a> * astrohelion::BaseArcset::getSysData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the a pointer to the system data object associated with this arc. </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the system data object associated with this arc </dd></dl>

</div>
</div>
<a class="anchor" id="ad7bac542c52a8994739833999fe5b859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::BaseArcset::getTOF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the time-of-flight associated with a segment with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a segment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time-of-flight </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the segment with the specified ID is not located in the segIDMap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89a221ac94947dc15ad30c0a8a3f3b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::BaseArcset::getTOFByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time-of-flight for a specific segment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>node index (NOT the ID); if less than 0, the index counts backwards from the end of the nodeset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-dimensional time-of-flight along the specified segment </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a110ed64cd4f619d0d3634b9e2b0de339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::BaseArcset::getTol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the tolerance with which data in this object was computed. </p>
<dl class="section return"><dt>Returns</dt><dd>the tolerance with which data in this object was computed </dd></dl>

</div>
</div>
<a class="anchor" id="ac2d152e5b7d88e6d8184f4c1dfdf386f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::BaseArcset::getTotalTOF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the total time-of-flight along this arc. </p>
<p>This function sums the TOF along each segment; derived classes may override this function to use different methods. </p><dl class="section return"><dt>Returns</dt><dd>the total time-of-flight along this arc, units consistent with the <a class="el" href="classastrohelion_1_1_sys_data.html" title="Contains information about a system, like mass ratio, primary names, etc. ">SysData</a> object </dd></dl>

</div>
</div>
<a class="anchor" id="a73e4344c81c81585e4d0ab261acc04ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_core___initializer.html">Core_Initializer</a>&amp; astrohelion::Core::initializer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the core. </p>
<p>This function wraps a static <a class="el" href="classastrohelion_1_1_core___initializer.html" title="a structure that contains functions to initialize and unload global library stuff ...">Core_Initializer</a> object to avoid multiple instances of the initializer in different translation units </p><dl class="section return"><dt>Returns</dt><dd>a reference to the initializer </dd></dl>

</div>
</div>
<a class="anchor" id="ab5bb534b6186c55d99c2bba50a602fad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::initNodesSegsFromMat </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>pMatFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pVarName</em> = <code>VARNAME_NODESTATE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the vectors of node and segment objects from a *.mat file. </p>
<p>DEPRECATED; replaced by readLinkTable().</p>
<p>THIS FUNCTION MUST BE THE FIRST READ_DATA-TYPE FUNCTION CALLED because it clears the vectors and then initializes them by calculating the number of steps in the arcset object from the state vector. Individual nodes and segments are able to be called by index after this, though they will not contain data until another function is called to populate the data fields with values from the *.mat file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMatFile</td><td>pointer to an open matlab data file </td></tr>
    <tr><td class="paramname">pVarName</td><td>the name of a variable that has as many rows as there are steps along the data object. Valid variables typically include the time vector, state matrix, or acceleration matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the state vector variable cannot be read from the data file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5756bb8fecfc4f22e97aa5f6f956768"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::isInChronoOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the arcset is arranged in chronological order. </p>
<p>This is sufficient to prove that the arcset has been sorted, but not necessary; i.e., even if the flag is false, the arcset may indeed be in chronological order, but the oposite can not be true. </p><dl class="section return"><dt>Returns</dt><dd>a flag indicating if the arcset has been sorted into chronological order </dd></dl>

</div>
</div>
<a class="anchor" id="a8fc2ff12dd2472686b82073fc96b7d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> &amp; astrohelion::BaseArcset::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this object equal to another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>an arcset reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this arcset object </dd></dl>

</div>
</div>
<a class="anchor" id="ae41abbe5f68daed8ae6f68135ff384cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void astrohelion::BaseArcset::readFromMat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> * &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the object from a Matlab binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>the filepath to the Matlab file </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classastrohelion_1_1_arcset.html#a1eb5fcb0b00da71c093b771242e86457">astrohelion::Arcset</a>.</p>

</div>
</div>
<a class="anchor" id="a782b7fab931f7b2b6911881b273dd4c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_Constraints </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read constraints from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a cell array variable that stores the constraints </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaae41c6eb8584239a9836e2c39182aa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_NodeCtrl </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read node control data from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a variable that stores the node control data </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e08ca2b162b0eb12bb36d3624c90de7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_NodeEpoch </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read node epochs from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a variable that stores the node epochs </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad785bcffba15d35ed084116ef81c650"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_NodeExtraParam </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>varKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read node extra parameter data from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a variable that stores the node extra parameters </td></tr>
    <tr><td class="paramname">varKey</td><td>the key (i.e., name) of the extra parameter vector </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46b6d8e34094dfcf30a64cffd88cc6c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_NodeExtraParamVec </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>varKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read node extra parameter vectors from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a variable that stores the node extra parameter vectors </td></tr>
    <tr><td class="paramname">varKey</td><td>the key (i.e., name) of the extra parameter vector </td></tr>
    <tr><td class="paramname">len</td><td>the length of the extra parameter vector </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afca52cd23f13cbcd492a05efa0296ec5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_NodeState </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read node states from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a variable that stores the node states </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a022b00fc000c2b8096737dbbbd076d71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_NodeStateDeriv </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read node state derivatives from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a variable that stores the node state derivatives </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9769dd0cb4a0d0358d64961a5209bbdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_SegCtrlLaw </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classastrohelion_1_1_control_law.html">ControlLaw</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>refLaws</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read segment control law data from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a structure array variable that stores the segment control laws </td></tr>
    <tr><td class="paramname">refLaws</td><td>Reference to a vector of <a class="el" href="classastrohelion_1_1_control_law.html" title="Stores control law equations and derivatives for flexible applications throughout the astrohelion fra...">ControlLaw</a> pointers. As control laws are read from the matio variable, unique control laws are constructed and allocated on the stack. The user must manually delete the <a class="el" href="classastrohelion_1_1_control_law.html" title="Stores control law equations and derivatives for flexible applications throughout the astrohelion fra...">ControlLaw</a> objects to avoid memory leaks. </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2754c59f053f7c2549cc9488510a8e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_SegState </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read segment state data from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a cell array variable that stores the segment states </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab490ea54a4faa9092bdc9b1c5f6fb5f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_SegSTM </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read segment STM data from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a cell array variable that stores the segment STMs </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d9465e64c9ac0cbe74f8046610c4395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_SegTime </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read segment time data from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a cell array variable that stores the segment times </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29eb48b323388a0856dfe51c5a0faa62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::BaseArcset::readVar_SegTOF </td>
          <td>(</td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>pVar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read segment TOF data from a matio variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pVar</td><td>a pointer to a variable that stores the segment TOFs </td></tr>
    <tr><td class="paramname">saveTp</td><td>Describes the amount of detail that was saved to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the matio variable needs to be freed </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there are any errors while importing the data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44fc576199290ea0baa914efe85c2841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void astrohelion::BaseArcset::saveToMat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filepath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6a">Save_tp</a>&#160;</td>
          <td class="paramname"><em>saveTp</em> = <code><a class="el" href="namespaceastrohelion.html#a93445970eb6efda1fdad3b3c90ae9c6aa77b1a0ed8f761a265d8ad995f040bef2">Save_tp::SAVE_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saves the object to a Matlab binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filepath</td><td>the filepath to the Matlab file </td></tr>
    <tr><td class="paramname">saveTp</td><td>describe how much data should be saved </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classastrohelion_1_1_arcset.html#a739892098b5eb80c5badd55b7f5d454e">astrohelion::Arcset</a>.</p>

</div>
</div>
<a class="anchor" id="af112fc10dd6f15f81d417f9f3c9fa218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setEpoch </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epoch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the epoch time associated with a node with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a node </td></tr>
    <tr><td class="paramname">epoch</td><td>the epoch time </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03d8b2b867f969c0e668ac69ff1e5cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setEpochByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epoch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the epoch time for a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>the node index within the <code>nodes</code> storage array; This value is not necessarily the same as the unique ID assigned to the node when it was added to the arcset object. If <code>ix</code> is negative, this index will cound backwards from the end of the array.</td></tr>
    <tr><td class="paramname">epoch</td><td>the epoch time </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a545efea7aa7c0897d785ac0154bb3934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state vector associated with a node with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a node </td></tr>
    <tr><td class="paramname">state</td><td>the state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a765f9ee99f0db3fa0569b5d8f23c17cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setStateByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>stateVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state vector for a specific node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>the node index within the <code>nodes</code> storage array; This value is not necessarily the same as the unique ID assigned to the node when it was added to the arcset object. If <code>ix</code> is negative, this index will cound backwards from the end of the array.</td></tr>
    <tr><td class="paramname">stateVec</td><td>vector of non-dimensional state values </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acea7cf208ac82e6fbcf82ed46976192f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setStateDeriv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>qdot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state derivative vector associated with a node with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a node </td></tr>
    <tr><td class="paramname">qdot</td><td>the acceleration vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>qdot</code> does not have the same size as the state vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b6725f4e543a5717af06a170b3ee411"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setStateDerivByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>derivVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state derivative vector for a specific step/node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>the node index within the <code>nodes</code> storage array; This value is not necessarily the same as the unique ID assigned to the node when it was added to the arcset object. If <code>n</code> is negative, this index will cound backwards from the end of the array.</td></tr>
    <tr><td class="paramname">derivVec</td><td>state derivative vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>qdot</code> does not have the same size as the state vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad82249c5ec1c86c17dc82373a33beb6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setSTM </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td>
          <td class="paramname"><em>stm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the STM associated with a segment with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of a segment </td></tr>
    <tr><td class="paramname">stm</td><td>the STM </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>id</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the STM is not the size specified by the DynamicalModel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9139a5b3ca9ffe562613ebbb037a3998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setSTMByIx </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td>
          <td class="paramname"><em>stm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the STM for a specific step/node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>index of the segment with the <code>segs</code> storage array; if it is negative, it will count backwards from the end of the array.</td></tr>
    <tr><td class="paramname">stm</td><td>a matrix containing the STM </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>ix</code> is out of bounds </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the STM is not the size specified by the DynamicalModel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02a4c7d4b7fb10572fe8bfe0fe9d534b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::setTol </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the computational tolerance for this data object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the tolerance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af83b5ba87b900936c6f828acda6ee6be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structastrohelion_1_1_arc_piece.html">ArcPiece</a> &gt; astrohelion::BaseArcset::sortArcset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structastrohelion_1_1_arc_piece.html">ArcPiece</a> &gt;&#160;</td>
          <td class="paramname"><em>prevPieces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sort the arcset into chronological order beginning at a specified node. </p>
<p>This function operates recursively to sort all branches of the arcset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ID</td><td>the ID of a node in the arcset </td></tr>
    <tr><td class="paramname">prevPieces</td><td>already sorted <a class="el" href="structastrohelion_1_1_arc_piece.html" title="A structure used to represent nodes and segments. ">ArcPiece</a> objects from higher levels of the recursive process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of <a class="el" href="structastrohelion_1_1_arc_piece.html" title="A structure used to represent nodes and segments. ">ArcPiece</a> objects that represent the chronological order of the nodes and segments that make up the section of the arcset that contains the specified node</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the ID is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40a2e3f124a0fe971475fb3c55e35d7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::sortChrono </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rearrange the nodes and segments so that they are listed in chronological order in their storage arrays. </p>
<p>This does not change the ID of any of the nodes or segments, only their index within the storage array. After calling this function, accessing the -1 node or segment will return the latest (in time) object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>if true, the arcset will be sorted regardless of the value of the <a class="el" href="classastrohelion_1_1_base_arcset.html#ac5756bb8fecfc4f22e97aa5f6f956768" title="Determine if the arcset is arranged in chronological order. ">isInChronoOrder()</a> flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the <a class="el" href="classastrohelion_1_1_base_arcset.html#afd55faf6c1bb134d0269de20bc68b57a" title="Determine what order to place the nodes and segments of this object into to achieve a chronological p...">getChronoOrder()</a> sorting algorithm returns a set of <a class="el" href="structastrohelion_1_1_arc_piece.html" title="A structure used to represent nodes and segments. ">ArcPiece</a> objects that has a different size than the combined node and segment vectors, the function is aborted as it is likely a node or segment was skipped and we don't want to lose information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75b0b4cdd57c4a2ecfb2a52b43b58497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classastrohelion_1_1_base_arcset.html">BaseArcset</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum two arcset objects. </p>
<p>This function returns <code>result</code> = <code>lhs</code> + <code>rhs</code>; Both <code>lhs</code> and <code>rhs</code> are copied and sorted into chronological order. The <code>rhs</code> is then appended to the end of <code>lhs</code> with no time-of-flight between the end of <code>lhs</code> and the beginning of <code>rhs</code>. The first node of <code>rhs</code> is deleted if the final node on <code>lhs</code> is an origin node, i.e., if the two progress in different time directions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>pointer to an arcset object </td></tr>
    <tr><td class="paramname">rhs</td><td>pointer to an arcset object </td></tr>
    <tr><td class="paramname">result</td><td>a pointer to the an arcset object that will store the result of the summing operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ef68a2edceb7a4d8a2b27f83b94c78b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::BaseArcset::updateEpochs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epoch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the epochs of all nodes such that time is continuous. </p>
<p>By specifying the epoch of one node in the set, all other nodes are updated using the segment times-of-flight between them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeID</td><td>the ID of a node to use as the base point </td></tr>
    <tr><td class="paramname">epoch</td><td>the epoch of the node with the specified ID. If the epoch currently stored in the node does not match this input value, the stored value is updated to match the specified epoch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac20bc83881569d27294ce76b4b67fb0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classastrohelion_1_1_constraint.html">Constraint</a>&gt; astrohelion::BaseArcset::cons {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A set of constraints that apply to the arc data object as a whole </p>

</div>
</div>
<a class="anchor" id="a8b7a64ee5e93ffe8c561117f143cbd6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, int&gt; astrohelion::BaseArcset::nodeIDMap {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The key is the ID of the node, the value is the index in node storage vector.</p>
<p>The current implementation requires that nextNodeID begin at 0 and increment by one through all integers. </p>

</div>
</div>
<a class="anchor" id="a4e932915cd0f354291a292f6288ad1ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classastrohelion_1_1_node.html">Node</a>&gt; astrohelion::BaseArcset::nodes {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains all nodes or integration steps along an arc data object </p>

</div>
</div>
<a class="anchor" id="a0523e7de274190cd42208515154f63ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classastrohelion_1_1_sys_data.html">SysData</a>* astrohelion::BaseArcset::pSysData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the system data object that the describes the system this arc exists in </p>

</div>
</div>
<a class="anchor" id="afd1ae1c103b27ebd13b7395a632c162b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, int&gt; astrohelion::BaseArcset::segIDMap {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The key is the ID of the segment, the value is the index in segment storage vector.</p>
<p>The current implementation requires that nextSegID begin at 0 and increment by one through all integers. </p>

</div>
</div>
<a class="anchor" id="ac50a772f7324c1692f112ac163f60f65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classastrohelion_1_1_segment.html">Segment</a>&gt; astrohelion::BaseArcset::segs {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Contains all segments that link the nodes of this object </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="_base_arcset_8hpp_source.html">BaseArcset.hpp</a></li>
<li>src/<a class="el" href="_base_arcset_8cpp.html">BaseArcset.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
