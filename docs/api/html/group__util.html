<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Astrohelion: Utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Astrohelion
   </div>
   <div id="projectbrief">An open source multi-body astrodynamics toolkit for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab702106cf3b3e96750b6845ded4e0299"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab702106cf3b3e96750b6845ded4e0299">RESET</a>&#160;&#160;&#160;&quot;\033[0m&quot;</td></tr>
<tr class="separator:gab702106cf3b3e96750b6845ded4e0299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3b25cba33b07c303f3060fe41887f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga7b3b25cba33b07c303f3060fe41887f6">BLACK</a>&#160;&#160;&#160;&quot;\033[30m&quot;</td></tr>
<tr class="separator:ga7b3b25cba33b07c303f3060fe41887f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d23feea868a983c8c2b661e1e16972f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga8d23feea868a983c8c2b661e1e16972f">RED</a>&#160;&#160;&#160;&quot;\033[31m&quot;</td></tr>
<tr class="separator:ga8d23feea868a983c8c2b661e1e16972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbc006ea433ad708fdee3e82996e721"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gacfbc006ea433ad708fdee3e82996e721">GREEN</a>&#160;&#160;&#160;&quot;\033[32m&quot;</td></tr>
<tr class="separator:gacfbc006ea433ad708fdee3e82996e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf681265909adf3d3e8116c93c0ba179"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gabf681265909adf3d3e8116c93c0ba179">YELLOW</a>&#160;&#160;&#160;&quot;\033[33m&quot;</td></tr>
<tr class="separator:gabf681265909adf3d3e8116c93c0ba179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d10e672abb49ad63eeaa8aaef57c38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga79d10e672abb49ad63eeaa8aaef57c38">BLUE</a>&#160;&#160;&#160;&quot;\033[34m&quot;</td></tr>
<tr class="separator:ga79d10e672abb49ad63eeaa8aaef57c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f699060902f800f12aaae150f3a708e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga6f699060902f800f12aaae150f3a708e">MAGENTA</a>&#160;&#160;&#160;&quot;\033[35m&quot;</td></tr>
<tr class="separator:ga6f699060902f800f12aaae150f3a708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad243f93c16bc4c1d3e0a13b84421d760"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gad243f93c16bc4c1d3e0a13b84421d760">CYAN</a>&#160;&#160;&#160;&quot;\033[36m&quot;</td></tr>
<tr class="separator:gad243f93c16bc4c1d3e0a13b84421d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b537f5fa5c109d3c05c13d6b18f382"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga87b537f5fa5c109d3c05c13d6b18f382">WHITE</a>&#160;&#160;&#160;&quot;\033[37m&quot;</td></tr>
<tr class="separator:ga87b537f5fa5c109d3c05c13d6b18f382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2fe95894117165b29036718221979f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaef2fe95894117165b29036718221979f">BOLDBLACK</a>&#160;&#160;&#160;&quot;\033[1m\033[30m&quot;</td></tr>
<tr class="separator:gaef2fe95894117165b29036718221979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab912d02c7998c3d47d05f87be4e2c920"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab912d02c7998c3d47d05f87be4e2c920">BOLDRED</a>&#160;&#160;&#160;&quot;\033[1m\033[31m&quot;</td></tr>
<tr class="separator:gab912d02c7998c3d47d05f87be4e2c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6c893a1703c33ede7d702fe5f97c91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4a6c893a1703c33ede7d702fe5f97c91">BOLDGREEN</a>&#160;&#160;&#160;&quot;\033[1m\033[32m&quot;</td></tr>
<tr class="separator:ga4a6c893a1703c33ede7d702fe5f97c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cec79108dfc3c61e8e32d390ec28b26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga8cec79108dfc3c61e8e32d390ec28b26">BOLDYELLOW</a>&#160;&#160;&#160;&quot;\033[1m\033[33m&quot;</td></tr>
<tr class="separator:ga8cec79108dfc3c61e8e32d390ec28b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e77c19555cbd15bcc744ff36a18635"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga11e77c19555cbd15bcc744ff36a18635">BOLDBLUE</a>&#160;&#160;&#160;&quot;\033[1m\033[34m&quot;</td></tr>
<tr class="separator:ga11e77c19555cbd15bcc744ff36a18635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4723c5ee12cfca16e2172b57b99cb07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gac4723c5ee12cfca16e2172b57b99cb07">BOLDMAGENTA</a>&#160;&#160;&#160;&quot;\033[1m\033[35m&quot;</td></tr>
<tr class="separator:gac4723c5ee12cfca16e2172b57b99cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87af5e6363eb1913b17f24dcb60a22d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gae87af5e6363eb1913b17f24dcb60a22d">BOLDCYAN</a>&#160;&#160;&#160;&quot;\033[1m\033[36m&quot;</td></tr>
<tr class="separator:gae87af5e6363eb1913b17f24dcb60a22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ef051614aa0bd503b0a18ee158c5d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa4ef051614aa0bd503b0a18ee158c5d7">BOLDWHITE</a>&#160;&#160;&#160;&quot;\033[1m\033[37m&quot;</td></tr>
<tr class="separator:gaa4ef051614aa0bd503b0a18ee158c5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad96ba952870e0be31d187b8415b9837c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad96ba952870e0be31d187b8415b9837c"></a>
typedef std::pair&lt; unsigned int, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gad96ba952870e0be31d187b8415b9837c">astrohelion::IndexValuePair</a></td></tr>
<tr class="memdesc:gad96ba952870e0be31d187b8415b9837c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a type that stores an index and a value as a pair. This is used in parallel sorting to return both the minimum value and the associated index. See <a class="el" href="group__util.html#ga7d85ac5d83806da4e8b800267f9e986e" title="Sort eigenvalues. ">Calculations::sortEig()</a> for an example use case. <br /></td></tr>
<tr class="separator:gad96ba952870e0be31d187b8415b9837c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga88ff7998e06bb38e41f325b674816d38"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga88ff7998e06bb38e41f325b674816d38">astrohelion::getCPUTime</a> ()</td></tr>
<tr class="memdesc:ga88ff7998e06bb38e41f325b674816d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current CPU time in seconds past some reference.  <a href="group__util.html#ga88ff7998e06bb38e41f325b674816d38">More...</a><br /></td></tr>
<tr class="separator:ga88ff7998e06bb38e41f325b674816d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57dc4b7dfed3611d2ef2f266d8bea62c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga57dc4b7dfed3611d2ef2f266d8bea62c">astrohelion::complexToStr</a> (std::complex&lt; double &gt; num)</td></tr>
<tr class="memdesc:ga57dc4b7dfed3611d2ef2f266d8bea62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a complex number into a string, e.g. 1.2345 + 0.9876j.  <a href="group__util.html#ga57dc4b7dfed3611d2ef2f266d8bea62c">More...</a><br /></td></tr>
<tr class="separator:ga57dc4b7dfed3611d2ef2f266d8bea62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab475c37dc35eebe25514c0e5c7061711"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab475c37dc35eebe25514c0e5c7061711"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab475c37dc35eebe25514c0e5c7061711">astrohelion::waitForUser</a> ()</td></tr>
<tr class="memdesc:gab475c37dc35eebe25514c0e5c7061711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend operation until the user presses a key. <br /></td></tr>
<tr class="separator:gab475c37dc35eebe25514c0e5c7061711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d7bcf787a41fe94ab45376561b615c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga80d7bcf787a41fe94ab45376561b615c">astrohelion::getNameFromSpiceID</a> (int ID)</td></tr>
<tr class="memdesc:ga80d7bcf787a41fe94ab45376561b615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a string representing the name of a spacecraft or celestial body from its SPICE ID Code.  <a href="group__util.html#ga80d7bcf787a41fe94ab45376561b615c">More...</a><br /></td></tr>
<tr class="separator:ga80d7bcf787a41fe94ab45376561b615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac537f011ec853ad6e180fe5bdd5f2ca7"><td class="memItemLeft" align="right" valign="top">SpiceInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gac537f011ec853ad6e180fe5bdd5f2ca7">astrohelion::getSpiceIDFromName</a> (const char *name)</td></tr>
<tr class="memdesc:gac537f011ec853ad6e180fe5bdd5f2ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a SPICE ID from a body name.  <a href="group__util.html#gac537f011ec853ad6e180fe5bdd5f2ca7">More...</a><br /></td></tr>
<tr class="separator:gac537f011ec853ad6e180fe5bdd5f2ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3cc438e6d244497a9fa54748e09c3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gafa3cc438e6d244497a9fa54748e09c3e">astrohelion::checkAndReThrowSpiceErr</a> (const char *customMsg)</td></tr>
<tr class="memdesc:gafa3cc438e6d244497a9fa54748e09c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if SPICE failed; if it did, throw a <a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a> with a custom error message.  <a href="group__util.html#gafa3cc438e6d244497a9fa54748e09c3e">More...</a><br /></td></tr>
<tr class="separator:gafa3cc438e6d244497a9fa54748e09c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b68c8eba2231ca76428b9414e6b1bfc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga8b68c8eba2231ca76428b9414e6b1bfc">astrohelion::resolveAngle</a> (double asinVal, double acosVal)</td></tr>
<tr class="memdesc:ga8b68c8eba2231ca76428b9414e6b1bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve double angle ambiquity from inverse trig functions.  <a href="group__util.html#ga8b68c8eba2231ca76428b9414e6b1bfc">More...</a><br /></td></tr>
<tr class="separator:ga8b68c8eba2231ca76428b9414e6b1bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e3afdce59fbddb2ee46721bad81e3c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab1e3afdce59fbddb2ee46721bad81e3c">astrohelion::boundValue</a> (double val, double min, double max)</td></tr>
<tr class="memdesc:gab1e3afdce59fbddb2ee46721bad81e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the value of a number within some bounds.  <a href="group__util.html#gab1e3afdce59fbddb2ee46721bad81e3c">More...</a><br /></td></tr>
<tr class="separator:gab1e3afdce59fbddb2ee46721bad81e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccfdbcaf731eebb9523e329157f7a2d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaccfdbcaf731eebb9523e329157f7a2d6">astrohelion::wrapToPi</a> (double val)</td></tr>
<tr class="memdesc:gaccfdbcaf731eebb9523e329157f7a2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and angle to its equivalent between -pi and pi.  <a href="group__util.html#gaccfdbcaf731eebb9523e329157f7a2d6">More...</a><br /></td></tr>
<tr class="separator:gaccfdbcaf731eebb9523e329157f7a2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c7c5cca3937b0616c960e0a55defd0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab4c7c5cca3937b0616c960e0a55defd0">astrohelion::eigenCompInfo2Str</a> (Eigen::ComputationInfo ci)</td></tr>
<tr class="memdesc:gab4c7c5cca3937b0616c960e0a55defd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an Eigen::ComputationInfo enumerated type into a human-readable string.  <a href="group__util.html#gab4c7c5cca3937b0616c960e0a55defd0">More...</a><br /></td></tr>
<tr class="separator:gab4c7c5cca3937b0616c960e0a55defd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c3960dbd7f378199f773252f135d361"><td class="memItemLeft" align="right" valign="top">IndexValuePair&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga6c3960dbd7f378199f773252f135d361">astrohelion::minVal</a> (IndexValuePair a, IndexValuePair b)</td></tr>
<tr class="memdesc:ga6c3960dbd7f378199f773252f135d361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the IndexValuePair with the minimum value.  <a href="group__util.html#ga6c3960dbd7f378199f773252f135d361">More...</a><br /></td></tr>
<tr class="separator:ga6c3960dbd7f378199f773252f135d361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027665ba49600ee4339eb7ccc902d28e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga027665ba49600ee4339eb7ccc902d28e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga027665ba49600ee4339eb7ccc902d28e">astrohelion::permute</a> (std::vector&lt; T &gt; values, unsigned int numSpots, std::vector&lt; unsigned int &gt; ixs, std::vector&lt; T &gt; *perms)</td></tr>
<tr class="memdesc:ga027665ba49600ee4339eb7ccc902d28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker function to compute permutations via recursion.  <a href="group__util.html#ga027665ba49600ee4339eb7ccc902d28e">More...</a><br /></td></tr>
<tr class="separator:ga027665ba49600ee4339eb7ccc902d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9ab2020c4b72bec9c8edc9c15f1b69d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf9ab2020c4b72bec9c8edc9c15f1b69d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaf9ab2020c4b72bec9c8edc9c15f1b69d">astrohelion::permute</a> (std::vector&lt; T &gt; values, std::vector&lt; unsigned int &gt; ixs, std::vector&lt; T &gt; *perms)</td></tr>
<tr class="memdesc:gaf9ab2020c4b72bec9c8edc9c15f1b69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker function to compute permutations via recursion without repeating values.  <a href="group__util.html#gaf9ab2020c4b72bec9c8edc9c15f1b69d">More...</a><br /></td></tr>
<tr class="separator:gaf9ab2020c4b72bec9c8edc9c15f1b69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9c80b3cb13e4c9ec345faf406717d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a9c80b3cb13e4c9ec345faf406717d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga0a9c80b3cb13e4c9ec345faf406717d6">astrohelion::aboutEquals</a> (T t1, T t2, double tol)</td></tr>
<tr class="memdesc:ga0a9c80b3cb13e4c9ec345faf406717d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two numbers are equal within a given tolerance.  <a href="group__util.html#ga0a9c80b3cb13e4c9ec345faf406717d6">More...</a><br /></td></tr>
<tr class="separator:ga0a9c80b3cb13e4c9ec345faf406717d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf5bf1474279ea4ce6bbe38cc334e09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaedf5bf1474279ea4ce6bbe38cc334e09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaedf5bf1474279ea4ce6bbe38cc334e09">astrohelion::aboutEquals</a> (std::vector&lt; T &gt; v1, std::vector&lt; T &gt; v2, double tol)</td></tr>
<tr class="separator:gaedf5bf1474279ea4ce6bbe38cc334e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc99cd89d8f4efeaf1cf0549d65f0469"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabc99cd89d8f4efeaf1cf0549d65f0469"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gabc99cd89d8f4efeaf1cf0549d65f0469">astrohelion::concatVecs</a> (std::vector&lt; T &gt; lhs, std::vector&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:gabc99cd89d8f4efeaf1cf0549d65f0469"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate two vectors  <a href="group__util.html#gabc99cd89d8f4efeaf1cf0549d65f0469">More...</a><br /></td></tr>
<tr class="separator:gabc99cd89d8f4efeaf1cf0549d65f0469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae767ae5ffe320de3187020ebb5dcd20"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaae767ae5ffe320de3187020ebb5dcd20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaae767ae5ffe320de3187020ebb5dcd20">astrohelion::createIdentity</a> (std::vector&lt; T &gt; &amp;matRef, unsigned int size)</td></tr>
<tr class="memdesc:gaae767ae5ffe320de3187020ebb5dcd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Identity matrix (e.g., to act as a dummy value for an STM)  <a href="group__util.html#gaae767ae5ffe320de3187020ebb5dcd20">More...</a><br /></td></tr>
<tr class="separator:gaae767ae5ffe320de3187020ebb5dcd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafb93290898836738423c62a8252205"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacafb93290898836738423c62a8252205"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gacafb93290898836738423c62a8252205">astrohelion::getSortedInd</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:gacafb93290898836738423c62a8252205"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort a vector and retrieve the indices of the sorted elements  <a href="group__util.html#gacafb93290898836738423c62a8252205">More...</a><br /></td></tr>
<tr class="separator:gacafb93290898836738423c62a8252205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76abd538691cb4c78cd8e7dcd85f190"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf76abd538691cb4c78cd8e7dcd85f190"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaf76abd538691cb4c78cd8e7dcd85f190">astrohelion::generatePerms</a> (std::vector&lt; T &gt; values, unsigned int n)</td></tr>
<tr class="memdesc:gaf76abd538691cb4c78cd8e7dcd85f190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all permutations of a set of n elements.  <a href="group__util.html#gaf76abd538691cb4c78cd8e7dcd85f190">More...</a><br /></td></tr>
<tr class="separator:gaf76abd538691cb4c78cd8e7dcd85f190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga731f3669b3facf50dc53a8e9c78d00f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga731f3669b3facf50dc53a8e9c78d00f8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga731f3669b3facf50dc53a8e9c78d00f8">astrohelion::generatePerms</a> (std::vector&lt; T &gt; values)</td></tr>
<tr class="memdesc:ga731f3669b3facf50dc53a8e9c78d00f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all permutations of a set of values without repeating the values.  <a href="group__util.html#ga731f3669b3facf50dc53a8e9c78d00f8">More...</a><br /></td></tr>
<tr class="separator:ga731f3669b3facf50dc53a8e9c78d00f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a76aaf64dd10c735c67728935373945"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a76aaf64dd10c735c67728935373945"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga3a76aaf64dd10c735c67728935373945">astrohelion::imag</a> (std::vector&lt; std::complex&lt; T &gt; &gt; compVec)</td></tr>
<tr class="memdesc:ga3a76aaf64dd10c735c67728935373945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the imaginary parts of every element of a vector.  <a href="group__util.html#ga3a76aaf64dd10c735c67728935373945">More...</a><br /></td></tr>
<tr class="separator:ga3a76aaf64dd10c735c67728935373945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab351385fdf91016b664acaecbcdb820a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab351385fdf91016b664acaecbcdb820a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gab351385fdf91016b664acaecbcdb820a">astrohelion::sum</a> (T *data, int length)</td></tr>
<tr class="memdesc:gab351385fdf91016b664acaecbcdb820a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sum all values in an array  <a href="group__util.html#gab351385fdf91016b664acaecbcdb820a">More...</a><br /></td></tr>
<tr class="separator:gab351385fdf91016b664acaecbcdb820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2285370a44ae7b7a45b25b594d915eeb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2285370a44ae7b7a45b25b594d915eeb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga2285370a44ae7b7a45b25b594d915eeb">astrohelion::sum</a> (std::vector&lt; T &gt; data)</td></tr>
<tr class="memdesc:ga2285370a44ae7b7a45b25b594d915eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum all values in a vector.  <a href="group__util.html#ga2285370a44ae7b7a45b25b594d915eeb">More...</a><br /></td></tr>
<tr class="separator:ga2285370a44ae7b7a45b25b594d915eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1ff60d4af4abee3c46c2895e200e7c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac1ff60d4af4abee3c46c2895e200e7c3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gac1ff60d4af4abee3c46c2895e200e7c3">astrohelion::mean</a> (T *data, int length)</td></tr>
<tr class="memdesc:gac1ff60d4af4abee3c46c2895e200e7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean (average) of an array of data.  <a href="group__util.html#gac1ff60d4af4abee3c46c2895e200e7c3">More...</a><br /></td></tr>
<tr class="separator:gac1ff60d4af4abee3c46c2895e200e7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga145908792689d801e6f32baf855972bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga145908792689d801e6f32baf855972bc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga145908792689d801e6f32baf855972bc">astrohelion::mean</a> (std::vector&lt; T &gt; data)</td></tr>
<tr class="memdesc:ga145908792689d801e6f32baf855972bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean (average) of a vector of data.  <a href="group__util.html#ga145908792689d801e6f32baf855972bc">More...</a><br /></td></tr>
<tr class="separator:ga145908792689d801e6f32baf855972bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b14977397b33216fba702b2eafa8880"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6b14977397b33216fba702b2eafa8880"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga6b14977397b33216fba702b2eafa8880">astrohelion::real</a> (std::vector&lt; std::complex&lt; T &gt; &gt; compVec)</td></tr>
<tr class="memdesc:ga6b14977397b33216fba702b2eafa8880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real parts of every element of a vector.  <a href="group__util.html#ga6b14977397b33216fba702b2eafa8880">More...</a><br /></td></tr>
<tr class="separator:ga6b14977397b33216fba702b2eafa8880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ebc44549945b1aec328349b1eb1133"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85ebc44549945b1aec328349b1eb1133"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga85ebc44549945b1aec328349b1eb1133">astrohelion::sign</a> (T num)</td></tr>
<tr class="memdesc:ga85ebc44549945b1aec328349b1eb1133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sign of a number.  <a href="group__util.html#ga85ebc44549945b1aec328349b1eb1133">More...</a><br /></td></tr>
<tr class="separator:ga85ebc44549945b1aec328349b1eb1133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd008250f4c2c8611e7d2f8031e6024"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7dd008250f4c2c8611e7d2f8031e6024"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga7dd008250f4c2c8611e7d2f8031e6024">astrohelion::compareMagnitude</a> (std::complex&lt; T &gt; lhs, std::complex&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:ga7dd008250f4c2c8611e7d2f8031e6024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two complex numbers by comparing their magnitudes.  <a href="group__util.html#ga7dd008250f4c2c8611e7d2f8031e6024">More...</a><br /></td></tr>
<tr class="separator:ga7dd008250f4c2c8611e7d2f8031e6024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd9f78c54a562d9cbaa7f28c185a1f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6dd9f78c54a562d9cbaa7f28c185a1f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga6dd9f78c54a562d9cbaa7f28c185a1f7">astrohelion::to_underlying</a> (T e) -&gt; typename std::underlying_type&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga6dd9f78c54a562d9cbaa7f28c185a1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly cast a strongly typed enumerate type to its underlying type.  <a href="group__util.html#ga6dd9f78c54a562d9cbaa7f28c185a1f7">More...</a><br /></td></tr>
<tr class="separator:ga6dd9f78c54a562d9cbaa7f28c185a1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf51c782835892ea3a417dec4db20a699"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf51c782835892ea3a417dec4db20a699"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf51c782835892ea3a417dec4db20a699"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>astrohelion::toCSV</b> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt; &amp;m, const char *filename)</td></tr>
<tr class="separator:gaf51c782835892ea3a417dec4db20a699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
General Analysis Functions</h2></td></tr>
<tr class="memitem:ga4c5aa3086bea7fb6f2007c10a3c058a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4c5aa3086bea7fb6f2007c10a3c058a4">astrohelion::dateToEphemerisTime</a> (const char *pDate)</td></tr>
<tr class="memdesc:ga4c5aa3086bea7fb6f2007c10a3c058a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a date to ephemeris time  <a href="group__util.html#ga4c5aa3086bea7fb6f2007c10a3c058a4">More...</a><br /></td></tr>
<tr class="separator:ga4c5aa3086bea7fb6f2007c10a3c058a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182088a2e80b199fe5b0480e4b7eccaf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga182088a2e80b199fe5b0480e4b7eccaf">astrohelion::gregorianToJulian</a> (double yr, double mo, double d, double h, double m, double s)</td></tr>
<tr class="memdesc:ga182088a2e80b199fe5b0480e4b7eccaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a gregorian date to Julian Date.  <a href="group__util.html#ga182088a2e80b199fe5b0480e4b7eccaf">More...</a><br /></td></tr>
<tr class="separator:ga182088a2e80b199fe5b0480e4b7eccaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61481cb7f8eba07060c00e3eb2b43fbe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga61481cb7f8eba07060c00e3eb2b43fbe">astrohelion::dateToGST</a> (double yr, double mo, double d, double h, double m, double s)</td></tr>
<tr class="memdesc:ga61481cb7f8eba07060c00e3eb2b43fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the Greenwich Sidereal Time (i.e., angle) at the specified date.  <a href="group__util.html#ga61481cb7f8eba07060c00e3eb2b43fbe">More...</a><br /></td></tr>
<tr class="separator:ga61481cb7f8eba07060c00e3eb2b43fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95726b58be1524bab6b7e58647d41363"><td class="memItemLeft" align="right" valign="top">MatrixXRd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga95726b58be1524bab6b7e58647d41363">astrohelion::getMirrorMat</a> (Mirror_tp mirrorType)</td></tr>
<tr class="memdesc:ga95726b58be1524bab6b7e58647d41363"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a matrix to mirror a 6-d state over the specified plane or axis  <a href="group__util.html#ga95726b58be1524bab6b7e58647d41363">More...</a><br /></td></tr>
<tr class="separator:ga95726b58be1524bab6b7e58647d41363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12e35d8c6f9875ef7e707e79fb603da"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cdouble &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gae12e35d8c6f9875ef7e707e79fb603da">astrohelion::getBalancedEigData</a> (MatrixXRd A, MatrixXRcd *pVecs)</td></tr>
<tr class="memdesc:gae12e35d8c6f9875ef7e707e79fb603da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the eigendata (values and, optionally, vectors) of the matrix A.  <a href="group__util.html#gae12e35d8c6f9875ef7e707e79fb603da">More...</a><br /></td></tr>
<tr class="separator:gae12e35d8c6f9875ef7e707e79fb603da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d8171727e39e2e3e6e6f63356401a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gae3d8171727e39e2e3e6e6f63356401a7">astrohelion::balanceMat</a> (MatrixXRd &amp;A, unsigned int &amp;low, unsigned int &amp;hi, std::vector&lt; double &gt; &amp;perms)</td></tr>
<tr class="memdesc:gae3d8171727e39e2e3e6e6f63356401a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance a matrix, <code>A</code>, to decrease rounding errors when computing eigenvalues.  <a href="group__util.html#gae3d8171727e39e2e3e6e6f63356401a7">More...</a><br /></td></tr>
<tr class="separator:gae3d8171727e39e2e3e6e6f63356401a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd323d6f0e3828b1db9bda0a09d2b708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gadd323d6f0e3828b1db9bda0a09d2b708">astrohelion::exchange</a> (unsigned int ix, unsigned int ix_move, std::vector&lt; double &gt; &amp;perms, unsigned int hi, unsigned int low, MatrixXRd &amp;A)</td></tr>
<tr class="memdesc:gadd323d6f0e3828b1db9bda0a09d2b708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchange rows and columns to reach the appropriate matrix structure.  <a href="group__util.html#gadd323d6f0e3828b1db9bda0a09d2b708">More...</a><br /></td></tr>
<tr class="separator:gadd323d6f0e3828b1db9bda0a09d2b708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb767e776a4494b7f47a03e07fcbd4fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaeb767e776a4494b7f47a03e07fcbd4fe">astrohelion::eigVec_backTrans</a> (unsigned int low, unsigned int hi, const std::vector&lt; double &gt; &amp;perms, MatrixXRcd &amp;vecs)</td></tr>
<tr class="memdesc:gaeb767e776a4494b7f47a03e07fcbd4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backtransform right-hand eigenvectors of a balanced matrix to retrieve the original eigenvectors.  <a href="group__util.html#gaeb767e776a4494b7f47a03e07fcbd4fe">More...</a><br /></td></tr>
<tr class="separator:gaeb767e776a4494b7f47a03e07fcbd4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d85ac5d83806da4e8b800267f9e986e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga7d85ac5d83806da4e8b800267f9e986e">astrohelion::sortEig</a> (const std::vector&lt; cdouble &gt; &amp;eigVals, const std::vector&lt; MatrixXRcd &gt; &amp;eigVecs)</td></tr>
<tr class="memdesc:ga7d85ac5d83806da4e8b800267f9e986e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort eigenvalues.  <a href="group__util.html#ga7d85ac5d83806da4e8b800267f9e986e">More...</a><br /></td></tr>
<tr class="separator:ga7d85ac5d83806da4e8b800267f9e986e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15db36118c3e03530b9997630b1e4b89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga15db36118c3e03530b9997630b1e4b89">astrohelion::getStabilityIndex</a> (std::vector&lt; cdouble &gt; eigs)</td></tr>
<tr class="memdesc:ga15db36118c3e03530b9997630b1e4b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stability index of a periodic orbit from a set of eigenvalues.  <a href="group__util.html#ga15db36118c3e03530b9997630b1e4b89">More...</a><br /></td></tr>
<tr class="separator:ga15db36118c3e03530b9997630b1e4b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0f5dcd605acc6d0212181a69746844"><td class="memItemLeft" align="right" valign="top">Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga3c0f5dcd605acc6d0212181a69746844">astrohelion::interpPointAtTime</a> (const Arcset *traj, double t)</td></tr>
<tr class="memdesc:ga3c0f5dcd605acc6d0212181a69746844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use numerical integration to find a node on a trajectory at the specified time.  <a href="group__util.html#ga3c0f5dcd605acc6d0212181a69746844">More...</a><br /></td></tr>
<tr class="separator:ga3c0f5dcd605acc6d0212181a69746844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc0a5355943301da1cbd29edcb951b3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc0a5355943301da1cbd29edcb951b3b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>astrohelion::reconstructArc</b> (const Arcset *pArcIn, Arcset *pArcOut)</td></tr>
<tr class="separator:gacc0a5355943301da1cbd29edcb951b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Orbit Determination</h2></td></tr>
<tr class="memitem:gaa1a6596be33ebd2549ab95f13ab81474"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa1a6596be33ebd2549ab95f13ab81474">astrohelion::getSpherical</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:gaa1a6596be33ebd2549ab95f13ab81474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a set of spherical coordinates the describe the position vector specified by x, y, and z.  <a href="group__util.html#gaa1a6596be33ebd2549ab95f13ab81474">More...</a><br /></td></tr>
<tr class="separator:gaa1a6596be33ebd2549ab95f13ab81474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc509230677aaf94f75d70edf69f89c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga2cc509230677aaf94f75d70edf69f89c">astrohelion::inert2LocalTangent</a> (std::vector&lt; double &gt; inertPos, double lat, double lon, double theta_mer)</td></tr>
<tr class="memdesc:ga2cc509230677aaf94f75d70edf69f89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert inertial coordinates to local tangent coordinates.  <a href="group__util.html#ga2cc509230677aaf94f75d70edf69f89c">More...</a><br /></td></tr>
<tr class="separator:ga2cc509230677aaf94f75d70edf69f89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d6ccbe0327d00b4e2e0ad30cbf0e744"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4d6ccbe0327d00b4e2e0ad30cbf0e744">astrohelion::localTangent2Inert</a> (std::vector&lt; double &gt; localPos, double lat, double lon, double theta_mer)</td></tr>
<tr class="memdesc:ga4d6ccbe0327d00b4e2e0ad30cbf0e744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert local tangent coordinates to inertial coordinates.  <a href="group__util.html#ga4d6ccbe0327d00b4e2e0ad30cbf0e744">More...</a><br /></td></tr>
<tr class="separator:ga4d6ccbe0327d00b4e2e0ad30cbf0e744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0479c696fb8fbd70d74d64adc43af25d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga0479c696fb8fbd70d74d64adc43af25d">astrohelion::azEl2LocalTangent</a> (double s, double az, double el)</td></tr>
<tr class="memdesc:ga0479c696fb8fbd70d74d64adc43af25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local tangent coordinates of an object given its azimuth, elevation, and range.  <a href="group__util.html#ga0479c696fb8fbd70d74d64adc43af25d">More...</a><br /></td></tr>
<tr class="separator:ga0479c696fb8fbd70d74d64adc43af25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CR3BP Analysis Functions</h2></td></tr>
<tr class="memitem:gad5844e716d4870797a453fa3ef882c93"><td class="memItemLeft" align="right" valign="top">Arcset_periodic&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cr3bp.html#gad5844e716d4870797a453fa3ef882c93">astrohelion::cr3bp_correctHalfPerSymPO</a> (const Arcset_cr3bp *halfPerGuess, Arcset_cr3bp *halfPerCorrected, Mirror_tp mirrorType, double tol, MultShootData *pItData)</td></tr>
<tr class="memdesc:gad5844e716d4870797a453fa3ef882c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct an arcset to be periodic using symmetry properties.  <a href="group__cr3bp.html#gad5844e716d4870797a453fa3ef882c93">More...</a><br /></td></tr>
<tr class="separator:gad5844e716d4870797a453fa3ef882c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2612ea957e9e36467a940e48472d6ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cr3bp.html#gac2612ea957e9e36467a940e48472d6ee">astrohelion::cr3bp_halfPO2fullPO</a> (const Arcset_cr3bp *halfPerArc, Arcset_periodic *pFullPO, Mirror_tp mirrorTp)</td></tr>
<tr class="memdesc:gac2612ea957e9e36467a940e48472d6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a full periodic orbit (PO) from a half-period representation of the orbit.  <a href="group__cr3bp.html#gac2612ea957e9e36467a940e48472d6ee">More...</a><br /></td></tr>
<tr class="separator:gac2612ea957e9e36467a940e48472d6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Standard Output</h2></td></tr>
<tr class="memitem:ga90a05459ef09a1ed0d347cf0ae2f145a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga90a05459ef09a1ed0d347cf0ae2f145a">astrohelion::printf</a> (const char *format,...)</td></tr>
<tr class="memdesc:ga90a05459ef09a1ed0d347cf0ae2f145a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload printf to pipe output to std::cout.  <a href="group__util.html#ga90a05459ef09a1ed0d347cf0ae2f145a">More...</a><br /></td></tr>
<tr class="separator:ga90a05459ef09a1ed0d347cf0ae2f145a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac68832c835c5de07bd2baff571a52fc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gac68832c835c5de07bd2baff571a52fc8">astrohelion::printVerb</a> (bool verbose, const char *format,...)</td></tr>
<tr class="memdesc:gac68832c835c5de07bd2baff571a52fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper function to print a message.  <a href="group__util.html#gac68832c835c5de07bd2baff571a52fc8">More...</a><br /></td></tr>
<tr class="separator:gac68832c835c5de07bd2baff571a52fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4b6719172d2fdb31064c7cd816c680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga1f4b6719172d2fdb31064c7cd816c680">astrohelion::printErr</a> (const char *format,...)</td></tr>
<tr class="memdesc:ga1f4b6719172d2fdb31064c7cd816c680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an error message to the standard output in red.  <a href="group__util.html#ga1f4b6719172d2fdb31064c7cd816c680">More...</a><br /></td></tr>
<tr class="separator:ga1f4b6719172d2fdb31064c7cd816c680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4af1fd97ed72fa6cc4cce80a577d98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gacc4af1fd97ed72fa6cc4cce80a577d98">astrohelion::printWarn</a> (const char *format,...)</td></tr>
<tr class="memdesc:gacc4af1fd97ed72fa6cc4cce80a577d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a warning messate to the standard output in yellow.  <a href="group__util.html#gacc4af1fd97ed72fa6cc4cce80a577d98">More...</a><br /></td></tr>
<tr class="separator:gacc4af1fd97ed72fa6cc4cce80a577d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2271d2dd6a802a2103f2b5ec19e8d51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa2271d2dd6a802a2103f2b5ec19e8d51">astrohelion::printColor</a> (const char *color, const char *format,...)</td></tr>
<tr class="memdesc:gaa2271d2dd6a802a2103f2b5ec19e8d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to the standard output using an ASCII escape-type color.  <a href="group__util.html#gaa2271d2dd6a802a2103f2b5ec19e8d51">More...</a><br /></td></tr>
<tr class="separator:gaa2271d2dd6a802a2103f2b5ec19e8d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade3fb67e12c7e7cd784f503efddb5386"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gade3fb67e12c7e7cd784f503efddb5386">astrohelion::printVerbColor</a> (bool verbose, const char *color, const char *format,...)</td></tr>
<tr class="memdesc:gade3fb67e12c7e7cd784f503efddb5386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to the standard output using an ASCII escape-type color.  <a href="group__util.html#gade3fb67e12c7e7cd784f503efddb5386">More...</a><br /></td></tr>
<tr class="separator:gade3fb67e12c7e7cd784f503efddb5386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087d01fb92d8e87ff55e673ff6438c94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga087d01fb92d8e87ff55e673ff6438c94">astrohelion::isColorOn</a> ()</td></tr>
<tr class="memdesc:ga087d01fb92d8e87ff55e673ff6438c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if colors should be used in text outputs.  <a href="group__util.html#ga087d01fb92d8e87ff55e673ff6438c94">More...</a><br /></td></tr>
<tr class="separator:ga087d01fb92d8e87ff55e673ff6438c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
File I/O</h2></td></tr>
<tr class="memitem:ga553ef6bddfc70952db18875f5df1e8f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga553ef6bddfc70952db18875f5df1e8f2">astrohelion::saveVar</a> (mat_t *matFile, matvar_t *matvar, const char *varName, matio_compression comp)</td></tr>
<tr class="memdesc:ga553ef6bddfc70952db18875f5df1e8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a variable to a .mat file, performing error checks along the way.  <a href="group__util.html#ga553ef6bddfc70952db18875f5df1e8f2">More...</a><br /></td></tr>
<tr class="separator:ga553ef6bddfc70952db18875f5df1e8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be30e012cbdb013c3fa4658e9131e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4be30e012cbdb013c3fa4658e9131e16">astrohelion::saveDoubleToFile</a> (mat_t *matfp, const char *varName, double data)</td></tr>
<tr class="memdesc:ga4be30e012cbdb013c3fa4658e9131e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a single double-precision value to a Matlab file.  <a href="group__util.html#ga4be30e012cbdb013c3fa4658e9131e16">More...</a><br /></td></tr>
<tr class="separator:ga4be30e012cbdb013c3fa4658e9131e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34add57d2a55dbb4531fc2380317afca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga34add57d2a55dbb4531fc2380317afca">astrohelion::saveMatrixToFile</a> (const char *filename, const char *varName, const std::vector&lt; double &gt; &amp;data, size_t rows, size_t cols)</td></tr>
<tr class="memdesc:ga34add57d2a55dbb4531fc2380317afca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a matrix of data to a Matlab .mat file.  <a href="group__util.html#ga34add57d2a55dbb4531fc2380317afca">More...</a><br /></td></tr>
<tr class="separator:ga34add57d2a55dbb4531fc2380317afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4282a6b6a3cd916591693421221fef09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4282a6b6a3cd916591693421221fef09">astrohelion::saveMatrixToFile</a> (mat_t *matfp, const char *varName, const std::vector&lt; double &gt; &amp;data, size_t rows, size_t cols)</td></tr>
<tr class="memdesc:ga4282a6b6a3cd916591693421221fef09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a matrix of data to an open matlab .mat file.  <a href="group__util.html#ga4282a6b6a3cd916591693421221fef09">More...</a><br /></td></tr>
<tr class="separator:ga4282a6b6a3cd916591693421221fef09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8dbbfc9dd4aaa93bc5efcaace5933de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gae8dbbfc9dd4aaa93bc5efcaace5933de">astrohelion::saveStringToFile</a> (mat_t *matfp, const char *varName, std::string text, const int strlen)</td></tr>
<tr class="memdesc:gae8dbbfc9dd4aaa93bc5efcaace5933de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a string to an open Matlab data file.  <a href="group__util.html#gae8dbbfc9dd4aaa93bc5efcaace5933de">More...</a><br /></td></tr>
<tr class="separator:gae8dbbfc9dd4aaa93bc5efcaace5933de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700e474992a0c8c70a5d87801d2022ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga700e474992a0c8c70a5d87801d2022ce">astrohelion::saveTimestampToFile</a> (mat_t *matfp, const char *varName)</td></tr>
<tr class="memdesc:ga700e474992a0c8c70a5d87801d2022ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a timestamp to a file.  <a href="group__util.html#ga700e474992a0c8c70a5d87801d2022ce">More...</a><br /></td></tr>
<tr class="separator:ga700e474992a0c8c70a5d87801d2022ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89fcd44ede02561762c5c005b35dab48"><td class="memItemLeft" align="right" valign="top">MatrixXRd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga89fcd44ede02561762c5c005b35dab48">astrohelion::readMatrixFromMat</a> (const char *filename, const char *varName)</td></tr>
<tr class="memdesc:ga89fcd44ede02561762c5c005b35dab48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix of doubles from a .mat file.  <a href="group__util.html#ga89fcd44ede02561762c5c005b35dab48">More...</a><br /></td></tr>
<tr class="separator:ga89fcd44ede02561762c5c005b35dab48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf353962161fbf0c85dd7313165903068"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaf353962161fbf0c85dd7313165903068">astrohelion::readDoubleFromMat</a> (mat_t *matFile, const char *varName)</td></tr>
<tr class="memdesc:gaf353962161fbf0c85dd7313165903068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a double from a mat file.  <a href="group__util.html#gaf353962161fbf0c85dd7313165903068">More...</a><br /></td></tr>
<tr class="separator:gaf353962161fbf0c85dd7313165903068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e3858d1fdc7289cac1f8e09cac9ef8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa0e3858d1fdc7289cac1f8e09cac9ef8">astrohelion::readStringFromMat</a> (mat_t *matFile, const char *varName, matio_types aType, matio_classes aClass)</td></tr>
<tr class="memdesc:gaa0e3858d1fdc7289cac1f8e09cac9ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string from a matlab file.  <a href="group__util.html#gaa0e3858d1fdc7289cac1f8e09cac9ef8">More...</a><br /></td></tr>
<tr class="separator:gaa0e3858d1fdc7289cac1f8e09cac9ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015a9ff07ff319121d5ef61779a61061"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga015a9ff07ff319121d5ef61779a61061"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>astrohelion::fileExists</b> (const char *filename)</td></tr>
<tr class="separator:ga015a9ff07ff319121d5ef61779a61061"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains all utility objects and methods </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7b3b25cba33b07c303f3060fe41887f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLACK&#160;&#160;&#160;&quot;\033[30m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text black </p>

</div>
</div>
<a class="anchor" id="ga79d10e672abb49ad63eeaa8aaef57c38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLUE&#160;&#160;&#160;&quot;\033[34m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text blue </p>

</div>
</div>
<a class="anchor" id="gaef2fe95894117165b29036718221979f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDBLACK&#160;&#160;&#160;&quot;\033[1m\033[30m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and black </p>

</div>
</div>
<a class="anchor" id="ga11e77c19555cbd15bcc744ff36a18635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDBLUE&#160;&#160;&#160;&quot;\033[1m\033[34m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and blue </p>

</div>
</div>
<a class="anchor" id="gae87af5e6363eb1913b17f24dcb60a22d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDCYAN&#160;&#160;&#160;&quot;\033[1m\033[36m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and cyan </p>

</div>
</div>
<a class="anchor" id="ga4a6c893a1703c33ede7d702fe5f97c91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDGREEN&#160;&#160;&#160;&quot;\033[1m\033[32m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and green </p>

</div>
</div>
<a class="anchor" id="gac4723c5ee12cfca16e2172b57b99cb07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDMAGENTA&#160;&#160;&#160;&quot;\033[1m\033[35m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and magenta </p>

</div>
</div>
<a class="anchor" id="gab912d02c7998c3d47d05f87be4e2c920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDRED&#160;&#160;&#160;&quot;\033[1m\033[31m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and red </p>

</div>
</div>
<a class="anchor" id="gaa4ef051614aa0bd503b0a18ee158c5d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDWHITE&#160;&#160;&#160;&quot;\033[1m\033[37m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and white </p>

</div>
</div>
<a class="anchor" id="ga8cec79108dfc3c61e8e32d390ec28b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDYELLOW&#160;&#160;&#160;&quot;\033[1m\033[33m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and yellow </p>

</div>
</div>
<a class="anchor" id="gad243f93c16bc4c1d3e0a13b84421d760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CYAN&#160;&#160;&#160;&quot;\033[36m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text cyan </p>

</div>
</div>
<a class="anchor" id="gacfbc006ea433ad708fdee3e82996e721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GREEN&#160;&#160;&#160;&quot;\033[32m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text green </p>

</div>
</div>
<a class="anchor" id="ga6f699060902f800f12aaae150f3a708e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAGENTA&#160;&#160;&#160;&quot;\033[35m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text magenta </p>

</div>
</div>
<a class="anchor" id="ga8d23feea868a983c8c2b661e1e16972f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RED&#160;&#160;&#160;&quot;\033[31m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text red </p>

</div>
</div>
<a class="anchor" id="gab702106cf3b3e96750b6845ded4e0299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RESET&#160;&#160;&#160;&quot;\033[0m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset ASCII text to default values </p>

</div>
</div>
<a class="anchor" id="ga87b537f5fa5c109d3c05c13d6b18f382"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WHITE&#160;&#160;&#160;&quot;\033[37m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text white </p>

</div>
</div>
<a class="anchor" id="gabf681265909adf3d3e8116c93c0ba179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YELLOW&#160;&#160;&#160;&quot;\033[33m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text yellow </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0a9c80b3cb13e4c9ec345faf406717d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::aboutEquals </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two numbers are equal within a given tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>a number </td></tr>
    <tr><td class="paramname">t2</td><td>another number </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the absolute value of the difference between t1 and t2 is less than the tolerance </dd></dl>

</div>
</div>
<a class="anchor" id="gaedf5bf1474279ea4ce6bbe38cc334e09"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::aboutEquals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ brief Check if two vectors are equal to a given tolerance </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>a vector </td></tr>
    <tr><td class="paramname">v2</td><td>another vector </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 and v2 are the same size and their corresponding elements differ by less than the tolerance </dd></dl>

</div>
</div>
<a class="anchor" id="ga0479c696fb8fbd70d74d64adc43af25d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::azEl2LocalTangent </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local tangent coordinates of an object given its azimuth, elevation, and range. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>range distance </td></tr>
    <tr><td class="paramname">az</td><td>azimuth, measured from North toward East, radians </td></tr>
    <tr><td class="paramname">el</td><td>elevation, measured from local horizontal, radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[r_E, r_N, r_Z] the position of the object in local tangent coordinates (East, North, Up), units that match the input range </dd></dl>

</div>
</div>
<a class="anchor" id="gae3d8171727e39e2e3e6e6f63356401a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::balanceMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>perms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Balance a matrix, <code>A</code>, to decrease rounding errors when computing eigenvalues. </p>
<p>The eigenvalues of the balanced matrix are equivalent to the eigenvalues of the un-balanced matrix if no rounding errors are present. However, the eigenvectors of the balanced matrix may be very different. Use the <code>eigVec_backTrans</code> function to retrieve the eigenvectors of the original matrix from the eigenvectors of the balanced matrix.</p>
<p>The balancing algorithm may time-out in some cases, thus, a maximum of 500 iterations are allowed to balance the STM. If this limit is reached, the function returns as usual but the balanced A matrix may not be balanced as well as it could be. (Reason for infinite loop is unknown; could be a coding error, though unlikely)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The matrix to balance. This matrix is manipulated in place, i.e., the original values are not preserved. </td></tr>
    <tr><td class="paramname">low</td><td>An integer that describes the form of the balanced (and permuted) matrix. The value passed in will be overwritten and filled with the value for the balanced matrix. </td></tr>
    <tr><td class="paramname">hi</td><td>An integer that describes the form of the balanced (and permuted) matrix. The value passed in will be overwritten and filled with the value for the balanced matrix. The values <code>hi</code> and <code>low</code> are defined such that A(i,j) = 0 if i &gt; j AND j = 1, ... , (low-1) or i = (hi+1), ... , n</td></tr>
    <tr><td class="paramname">perms</td><td>A vector that stores the scaling and permutation information for the balanced matrix. The vector passed in will be overwritten with the data for the balanced matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1e3afdce59fbddb2ee46721bad81e3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::boundValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the value of a number within some bounds. </p>
<p>This is particularly useful for arguments for inverse trig functions: small numerical errors may result in arccos(1 + eps) or arsin(-1 - eps) where eps is some small value. The resulting inverse trig function will be invalide and return NAN. In this case, use boundValue(value, -1, 1) to ensure that the argument inside the trig function is between -1 and 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to bound </td></tr>
    <tr><td class="paramname">min</td><td>minimum allowable value </td></tr>
    <tr><td class="paramname">max</td><td>maximum allowable value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value if it is within the bounds, or the min/max bound if val is outside the bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="gafa3cc438e6d244497a9fa54748e09c3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::checkAndReThrowSpiceErr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>customMsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if SPICE failed; if it did, throw a <a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a> with a custom error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customMsg</td><td>A message for the <a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if an error occured </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7dd008250f4c2c8611e7d2f8031e6024"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::compareMagnitude </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two complex numbers by comparing their magnitudes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the magnitude of lhs is less than the magnitude of rhs </dd></dl>

</div>
</div>
<a class="anchor" id="ga57dc4b7dfed3611d2ef2f266d8bea62c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string astrohelion::complexToStr </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; double &gt;&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn a complex number into a string, e.g. 1.2345 + 0.9876j. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>a complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the complex number as a string </dd></dl>

</div>
</div>
<a class="anchor" id="gabc99cd89d8f4efeaf1cf0549d65f0469"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::concatVecs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>concatenate two vectors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left-hand-side vector </td></tr>
    <tr><td class="paramname">rhs</td><td>the righ-hand-side vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new vector that includes both input vectors in order, i.e. [lhs, rhs] </dd></dl>

</div>
</div>
<a class="anchor" id="gad5844e716d4870797a453fa3ef882c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Arcset_periodic astrohelion::cr3bp_correctHalfPerSymPO </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_arcset__cr3bp.html">Arcset_cr3bp</a> *&#160;</td>
          <td class="paramname"><em>halfPerGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classastrohelion_1_1_arcset__cr3bp.html">Arcset_cr3bp</a> *&#160;</td>
          <td class="paramname"><em>halfPerCorrected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a8347f74809e68d46715a1fd9e28e2f86">Mirror_tp</a>&#160;</td>
          <td class="paramname"><em>mirrorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classastrohelion_1_1_mult_shoot_data.html">MultShootData</a> *&#160;</td>
          <td class="paramname"><em>pItData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correct an arcset to be periodic using symmetry properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halfPerGuess</td><td>an approximation of the first half of the periodic orbit. This arcset must include the constraints necessary to enforce the mirror conditions at either end of the half-period arc.</td></tr>
    <tr><td class="paramname">halfPerCorrected</td><td>the corrected half-period solution is stored here. Set to nullptr to discard this solution once the corrections process is complete. </td></tr>
    <tr><td class="paramname">mirrorType</td><td>Describes how the orbit is symmetric </td></tr>
    <tr><td class="paramname">tol</td><td>tolerance to enforce during the multiple-shooting process </td></tr>
    <tr><td class="paramname">pItData</td><td>iteration data from the multiple-shooting process is stored here. Set to nullptr to discard this data once the corrections process is complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A full revolution of the periodic orbit. Symmetry properties are leveraged to construct the second half of the orbit from the first half, which saves computation time and improves numerical accuracy. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2612ea957e9e36467a940e48472d6ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::cr3bp_halfPO2fullPO </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_arcset__cr3bp.html">Arcset_cr3bp</a> *&#160;</td>
          <td class="paramname"><em>halfPerArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classastrohelion_1_1_arcset__periodic.html">Arcset_periodic</a> *&#160;</td>
          <td class="paramname"><em>pFullPO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a8347f74809e68d46715a1fd9e28e2f86">Mirror_tp</a>&#160;</td>
          <td class="paramname"><em>mirrorTp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a full periodic orbit (PO) from a half-period representation of the orbit. </p>
<p>The half-period arc must start and end at mirror conditions. This function leverages the symmetry properties of the CR3BP to construct the second half of the full PO without numerical integration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">halfPerArc</td><td>An arc that represents exactly half of the full periodic orbit </td></tr>
    <tr><td class="paramname">pFullPO</td><td>A pointer to an object that stores the full periodic orbit </td></tr>
    <tr><td class="paramname">mirrorTp</td><td>Describes how the orbit is symmetric</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if either arcset pointer is null </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae767ae5ffe320de3187020ebb5dcd20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::createIdentity </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>matRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an Identity matrix (e.g., to act as a dummy value for an STM) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matRef</td><td>reference to a vector that stores matrix elements. Any nonzero elements are overwritten </td></tr>
    <tr><td class="paramname">size</td><td>side length of the matrix (e.g., the size of a 6x6 matrix is 6) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c5aa3086bea7fb6f2007c10a3c058a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::dateToEphemerisTime </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert a date to ephemeris time </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDate</td><td>a string representing the date. The string can be formatted in one of two ways. First, a Gregorian-style date: 'YYYY/MM/DD HH:II:SS' (UTC, 24-hour clock); The time 'HH:II:SS' can be ommited, and the function will assume the time is 0:0:00 Second, a Julian date (UTC) can be input with the format 'jd #' where '#' represents the Julian date.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the J2000 ephemeris time, or number of seconds after Jan 1, 2000 at 0:0:00 UTC. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the SPICE kernels cannot be loaded: the kernel names and filepaths are located in the settings XML file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61481cb7f8eba07060c00e3eb2b43fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::dateToGST </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the Greenwich Sidereal Time (i.e., angle) at the specified date. </p>
<p>Input date must be in UT1 time (always within +/- 0.9 seconds of UTC thanks to leapseconds)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yr</td><td>Year </td></tr>
    <tr><td class="paramname">mo</td><td>Month (Jan = 1, ..., Dec = 12) </td></tr>
    <tr><td class="paramname">d</td><td>Day of mongth </td></tr>
    <tr><td class="paramname">h</td><td>Hour (24-hr clock) </td></tr>
    <tr><td class="paramname">m</td><td>minute </td></tr>
    <tr><td class="paramname">s</td><td>second </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Greenwich Sidereal Time (GST) in radians at the specified date </dd></dl>

</div>
</div>
<a class="anchor" id="gab4c7c5cca3937b0616c960e0a55defd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string astrohelion::eigenCompInfo2Str </td>
          <td>(</td>
          <td class="paramtype">Eigen::ComputationInfo&#160;</td>
          <td class="paramname"><em>ci</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an Eigen::ComputationInfo enumerated type into a human-readable string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ci</td><td>enumerated type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a human-readable string representation of the enumerated type </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb767e776a4494b7f47a03e07fcbd4fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::eigVec_backTrans </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a864c99da947f1112284463c6b1136310">MatrixXRcd</a> &amp;&#160;</td>
          <td class="paramname"><em>vecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backtransform right-hand eigenvectors of a balanced matrix to retrieve the original eigenvectors. </p>
<p>When a matrix is balanced via <code><a class="el" href="group__util.html#gae3d8171727e39e2e3e6e6f63356401a7" title="Balance a matrix, A, to decrease rounding errors when computing eigenvalues. ">balanceMat()</a></code>, the eigenvalues are preserved but the eigenvectors are not due to permutations and scaling. This method transforms the right-hand eigenvectors of the balanced matrix, <code>vecs</code>, to the eigenvectors associated with the original, un-balanced matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td>value output from <code><a class="el" href="group__util.html#gae3d8171727e39e2e3e6e6f63356401a7" title="Balance a matrix, A, to decrease rounding errors when computing eigenvalues. ">balanceMat()</a></code> </td></tr>
    <tr><td class="paramname">hi</td><td>value output from <code><a class="el" href="group__util.html#gae3d8171727e39e2e3e6e6f63356401a7" title="Balance a matrix, A, to decrease rounding errors when computing eigenvalues. ">balanceMat()</a></code> </td></tr>
    <tr><td class="paramname">perms</td><td>vector containing permutation and scaling information; this data is used to transform the eigenvectors back to the original set. </td></tr>
    <tr><td class="paramname">vecs</td><td>matrix of eigenvectors (stored as columns) associated with a balanced matrix. These vectors are manipulated in place during the backtransformation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadd323d6f0e3828b1db9bda0a09d2b708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::exchange </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ix_move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>perms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchange rows and columns to reach the appropriate matrix structure. </p>
<p>This sub-routine is leveraged in the <code><a class="el" href="group__util.html#gae3d8171727e39e2e3e6e6f63356401a7" title="Balance a matrix, A, to decrease rounding errors when computing eigenvalues. ">balanceMat()</a></code> algorithm to arrange the matrix, A, which is being balanced, in a way that isolates trivial rows and columns to simplify the computations.</p>
<p>Source: Wilkinson, Reinsch: Handbook for Automatic Computation, pp. 315-326</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix</td><td>index of a row/column of A </td></tr>
    <tr><td class="paramname">ix_move</td><td>index of a row/column of A </td></tr>
    <tr><td class="paramname">perms</td><td>vector containing permutation and scaling information </td></tr>
    <tr><td class="paramname">hi</td><td>the current value of <code>hi</code> from the <code><a class="el" href="group__util.html#gae3d8171727e39e2e3e6e6f63356401a7" title="Balance a matrix, A, to decrease rounding errors when computing eigenvalues. ">balanceMat()</a></code> algorithm </td></tr>
    <tr><td class="paramname">low</td><td>the current value of <code>low</code> from the <code><a class="el" href="group__util.html#gae3d8171727e39e2e3e6e6f63356401a7" title="Balance a matrix, A, to decrease rounding errors when computing eigenvalues. ">balanceMat()</a></code> algorithm </td></tr>
    <tr><td class="paramname">A</td><td>The matrix that is being balanced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf76abd538691cb4c78cd8e7dcd85f190"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::generatePerms </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all permutations of a set of n elements. </p>
<p>Each of the n elements can contain any of the values stored in the values vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>a vector containing all possible values for each element </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the permutation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing all permutations, in row-major order where each row is a separate permutation </dd></dl>

</div>
</div>
<a class="anchor" id="ga731f3669b3facf50dc53a8e9c78d00f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::generatePerms </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all permutations of a set of values without repeating the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>the set of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing all permutations, in row-major order where each row is a seperate permutation of <code>values</code> </dd></dl>

</div>
</div>
<a class="anchor" id="gae12e35d8c6f9875ef7e707e79fb603da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; cdouble &gt; astrohelion::getBalancedEigData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a864c99da947f1112284463c6b1136310">MatrixXRcd</a> *&#160;</td>
          <td class="paramname"><em>pVecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the eigendata (values and, optionally, vectors) of the matrix A. </p>
<p>This method leverages matrix balancing to reduce round-off errors in the eigendata computation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a real matrix (passed by value because it will be manipulated in-place) </td></tr>
    <tr><td class="paramname">pVecs</td><td>pointer to a matrix of complex doubles; eigenvectors are stored here as columns, each column is associated with the eigenvalue of the same index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of complex doubles that contains the eigenvalues </dd></dl>

</div>
</div>
<a class="anchor" id="ga88ff7998e06bb38e41f325b674816d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::getCPUTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current CPU time in seconds past some reference. </p>
<dl class="section return"><dt>Returns</dt><dd>the current CPU time in seconds past some reference </dd></dl>

</div>
</div>
<a class="anchor" id="ga95726b58be1524bab6b7e58647d41363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXRd astrohelion::getMirrorMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a8347f74809e68d46715a1fd9e28e2f86">Mirror_tp</a>&#160;</td>
          <td class="paramname"><em>mirrorType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct a matrix to mirror a 6-d state over the specified plane or axis </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mirrorType</td><td>describes how to mirror a 6-d state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 6x6 matrix that will mirror a 6-d state over the specified plane or axis </dd></dl>

</div>
</div>
<a class="anchor" id="ga80d7bcf787a41fe94ab45376561b615c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string astrohelion::getNameFromSpiceID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a string representing the name of a spacecraft or celestial body from its SPICE ID Code. </p>
<p>For a list of SPICE IDs, see the <a href="http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/req/naif_ids.html">NAIF ID Page</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ID</td><td>Integer ID Code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the body or satellite </dd></dl>

</div>
</div>
<a class="anchor" id="gacafb93290898836738423c62a8252205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; astrohelion::getSortedInd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sort a vector and retrieve the indices of the sorted elements </p>
<p>Takes a copy of a vector and sorts it, retaining the original indices of the elements. For example, sorting {1,3,2} would return the indices {0,2,1}.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the indices of the sorted elements </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1a6596be33ebd2549ab95f13ab81474"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::getSpherical </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine a set of spherical coordinates the describe the position vector specified by x, y, and z. </p>
<p>The longitude angle measures in the in-plane angle, measured from the +x-axis in a right-handed rotationg about the +z-axis. Latitude represents the out-of-plane angle measured from the xy-plane, with positive angles representing points with positive z-coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-coordinate </td></tr>
    <tr><td class="paramname">y</td><td>y-coordinate </td></tr>
    <tr><td class="paramname">z</td><td>z-coordinate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing {lat, long, R} in radians and the distance units of x, y, and z. Latitude takes a value between -pi/2 and pi/2 while longitude takes a value between -pi and pi </dd></dl>

</div>
</div>
<a class="anchor" id="gac537f011ec853ad6e180fe5bdd5f2ca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SpiceInt astrohelion::getSpiceIDFromName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a SPICE ID from a body name. </p>
<p>Body names are case insensitive and leading/trailing spaces are not important. However, when the name is made up of more than word, they must be separated by at least one space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>body name to be translated to a SPICE ID code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SPICE integer ID code </dd></dl>

</div>
</div>
<a class="anchor" id="ga15db36118c3e03530b9997630b1e4b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::getStabilityIndex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceastrohelion.html#adad21911fcb9bf6db78b0ee09397edd1">cdouble</a> &gt;&#160;</td>
          <td class="paramname"><em>eigs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the stability index of a periodic orbit from a set of eigenvalues. </p>
<p>This algorithm assumes the orbit is periodic and that the eigenvalues have been sorted (so they come in pairs).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigs</td><td>A 6-element vector of eigenvalues associated with a periodic orbit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stability index, or NAN if no real, reciprocal eigenvalue pair is found </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>eigs</code> does not have six elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga182088a2e80b199fe5b0480e4b7eccaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::gregorianToJulian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a gregorian date to Julian Date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yr</td><td>Year </td></tr>
    <tr><td class="paramname">mo</td><td>Month (Jan = 1, ..., Dec = 12) </td></tr>
    <tr><td class="paramname">d</td><td>Day of mongth </td></tr>
    <tr><td class="paramname">h</td><td>Hour (24-hr clock) </td></tr>
    <tr><td class="paramname">m</td><td>minute </td></tr>
    <tr><td class="paramname">s</td><td>second </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Julian Date (days) </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a76aaf64dd10c735c67728935373945"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::imag </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>compVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the imaginary parts of every element of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compVec</td><td>a vector of complex numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the imaginary parts of the complex vector </dd></dl>

</div>
</div>
<a class="anchor" id="ga2cc509230677aaf94f75d70edf69f89c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::inert2LocalTangent </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>inertPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_mer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert inertial coordinates to local tangent coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inertPos</td><td>Object position in inertial, cartesian (x,y,z) coordinates </td></tr>
    <tr><td class="paramname">lat</td><td>Latitude angle, radians, measured from the inertial xy plane; above the plane (z &gt; 0) is a positive latitude. </td></tr>
    <tr><td class="paramname">lon</td><td>Longitude angle, radians, measured from reference meridian in a positive, right-handed rotation about inertial z </td></tr>
    <tr><td class="paramname">theta_mer</td><td>Meridian longitude, radians, measured from inertial x in a positive, right-handed rotation about inertial z. For example, Earth ground stations' longitudes are relative to the Greenwich Meridian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the object in local tangent, cartesian coordinates (East, North, Up) as viewed from the specified latitude and longitude </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c0f5dcd605acc6d0212181a69746844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Node astrohelion::interpPointAtTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_arcset.html">Arcset</a> *&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use numerical integration to find a node on a trajectory at the specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traj</td><td>An arcset </td></tr>
    <tr><td class="paramname">t</td><td>The time at which the node is located</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A node on the specified trajectory at time <code>t</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ga087d01fb92d8e87ff55e673ff6438c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::isColorOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if colors should be used in text outputs. </p>
<p>By default, colored output is enabled. However, by setting the ASTRO_COLOR environment variable to 0, color output is disabled. For example, <code>export ASTRO_COLOR=0</code> on a Linux machine disables colored output. </p><dl class="section return"><dt>Returns</dt><dd>whether or not color should be used in outputs </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d6ccbe0327d00b4e2e0ad30cbf0e744"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::localTangent2Inert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>localPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_mer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert local tangent coordinates to inertial coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localPos</td><td>Object position in local tangent, cartesian (East, North, Up) coordinates </td></tr>
    <tr><td class="paramname">lat</td><td>Latitude angle, radians, measured from the inertial xy plane; above the plane (z &gt; 0) is a positive latitude. </td></tr>
    <tr><td class="paramname">lon</td><td>Longitude angle, radians, measured from reference meridian in a positive, right-handed rotation about inertial z </td></tr>
    <tr><td class="paramname">theta_mer</td><td>Meridian longitude, radians, measured from inertial x in a positive, right-handed rotation about inertial z. For example, Earth ground stations' longitudes are relative to the Greenwich Meridian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the object in inertial, cartesian coordinates (x, y, z) as viewed from the specified latitude and longitude </dd></dl>

</div>
</div>
<a class="anchor" id="gac1ff60d4af4abee3c46c2895e200e7c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T astrohelion::mean </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean (average) of an array of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>an array of numbers </td></tr>
    <tr><td class="paramname">length</td><td>the length of the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mean </dd></dl>

</div>
</div>
<a class="anchor" id="ga145908792689d801e6f32baf855972bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T astrohelion::mean </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean (average) of a vector of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a vector of numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a numerical type, like int, double, long, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mean </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c3960dbd7f378199f773252f135d361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IndexValuePair astrohelion::minVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__util.html#gad96ba952870e0be31d187b8415b9837c">IndexValuePair</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__util.html#gad96ba952870e0be31d187b8415b9837c">IndexValuePair</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the IndexValuePair with the minimum value. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>an IndexValuePair </td></tr>
    <tr><td class="paramname">b</td><td>an IndexValuePair</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whichever of a or b that has the smaller value </dd></dl>

</div>
</div>
<a class="anchor" id="ga027665ba49600ee4339eb7ccc902d28e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::permute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numSpots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>ixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>perms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Worker function to compute permutations via recursion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>a vector of all possible values for each element </td></tr>
    <tr><td class="paramname">numSpots</td><td>the number of elements, or "spots" </td></tr>
    <tr><td class="paramname">ixs</td><td>the indices of values for each element in the current permuation </td></tr>
    <tr><td class="paramname">perms</td><td>a pointer to a storage vector for the permutations; stored in row-major order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf9ab2020c4b72bec9c8edc9c15f1b69d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::permute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>ixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>perms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Worker function to compute permutations via recursion without repeating values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>a vector of all possible values </td></tr>
    <tr><td class="paramname">ixs</td><td>the indices of values for each element in the current permutation </td></tr>
    <tr><td class="paramname">perms</td><td>a pointer to a storage vector for the permutations; stored in row-major order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa2271d2dd6a802a2103f2b5ec19e8d51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::printColor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to the standard output using an ASCII escape-type color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>one of the constant color values stored in the ascii-output header </td></tr>
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f4b6719172d2fdb31064c7cd816c680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::printErr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an error message to the standard output in red. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90a05459ef09a1ed0d347cf0ae2f145a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload printf to pipe output to std::cout. </p>
<p>Functionally equivalent to the usual printf, but this output can be captured by MATLAB (or other external callers) when compiled</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac68832c835c5de07bd2baff571a52fc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::printVerb </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper function to print a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>whether or not to be verbose; message is not printed if verbose is false </td></tr>
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade3fb67e12c7e7cd784f503efddb5386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::printVerbColor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to the standard output using an ASCII escape-type color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>whether or not to print the string </td></tr>
    <tr><td class="paramname">color</td><td>one of the constant color values stored in the ascii-output header </td></tr>
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc4af1fd97ed72fa6cc4cce80a577d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::printWarn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a warning messate to the standard output in yellow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf353962161fbf0c85dd7313165903068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::readDoubleFromMat </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a double from a mat file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matFile</td><td>a pointer to the matlab file in quesiton </td></tr>
    <tr><td class="paramname">varName</td><td>the name of the variable in the mat file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the variable </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there is trouble reading or parsing the variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89fcd44ede02561762c5c005b35dab48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXRd astrohelion::readMatrixFromMat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a matrix of doubles from a .mat file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>relative or absolute path to the .mat data file </td></tr>
    <tr><td class="paramname">varName</td><td>the name of the variable/matrix to read from the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a column-major-order vector containing the data from the desired matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the file cannot be opened, if the variable doesn't exist, or if the variable contains something other than doubles </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the data file cannot be opened or the variable cannot be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa0e3858d1fdc7289cac1f8e09cac9ef8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string astrohelion::readStringFromMat </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matio_types&#160;</td>
          <td class="paramname"><em>aType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matio_classes&#160;</td>
          <td class="paramname"><em>aClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a string from a matlab file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matFile</td><td>a pointer to the matlab file in questions </td></tr>
    <tr><td class="paramname">varName</td><td>the name of the variable in the mat file </td></tr>
    <tr><td class="paramname">aType</td><td>the expected variable type (e.g. MAT_T_UINT8) </td></tr>
    <tr><td class="paramname">aClass</td><td>the expected variable class (e.g. MAT_C_CHAR) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there is trouble reading or parsing the variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6b14977397b33216fba702b2eafa8880"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::real </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>compVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real parts of every element of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compVec</td><td>a vector of complex numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the real parts of the complex vector </dd></dl>

</div>
</div>
<a class="anchor" id="ga8b68c8eba2231ca76428b9414e6b1bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::resolveAngle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>asinVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acosVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve double angle ambiquity from inverse trig functions. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asinVal</td><td>The result of arcsin(value) </td></tr>
    <tr><td class="paramname">acosVal</td><td>The result of arccos(value)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common value between the double angles returned by arcsin(value) and arccos(value) </dd></dl>

</div>
</div>
<a class="anchor" id="ga4be30e012cbdb013c3fa4658e9131e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveDoubleToFile </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a single double-precision value to a Matlab file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matfp</td><td>a pointer to the matlab output file </td></tr>
    <tr><td class="paramname">varName</td><td>the name of the variable </td></tr>
    <tr><td class="paramname">data</td><td>data value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga34add57d2a55dbb4531fc2380317afca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveMatrixToFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a matrix of data to a Matlab .mat file. </p>
<p>The data passed in the <code>data</code> vector is transposed and saved to the specified Matlab file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name/path of the file </td></tr>
    <tr><td class="paramname">varName</td><td>variable name </td></tr>
    <tr><td class="paramname">data</td><td>vector of data in row-major order </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4282a6b6a3cd916591693421221fef09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveMatrixToFile </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a matrix of data to an open matlab .mat file. </p>
<p>The data passed in the <code>data</code> vector is transposed and saved to the specified Matlab file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matfp</td><td>An open Matlab .mat file </td></tr>
    <tr><td class="paramname">varName</td><td>name of the variable within the .mat file </td></tr>
    <tr><td class="paramname">data</td><td>a vector of data in row-major order </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>data</code> does not have enough elements to construct a matrix with the specified number of rows and columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae8dbbfc9dd4aaa93bc5efcaace5933de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveStringToFile </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>strlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a string to an open Matlab data file. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matfp</td><td>pointer to Matlab file </td></tr>
    <tr><td class="paramname">varName</td><td>name of the variable within the Matlab file </td></tr>
    <tr><td class="paramname">text</td><td>value of the variable within the Matlab file </td></tr>
    <tr><td class="paramname">strlen</td><td>number of characters (including the final nullptr char) in <code>text</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga700e474992a0c8c70a5d87801d2022ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveTimestampToFile </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a timestamp to a file. </p>
<p>The timestamp is saved as "hh:mm:ssUTC dd/mm/yyyy"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matfp</td><td>pointer to Matlab file </td></tr>
    <tr><td class="paramname">varName</td><td>name of the variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga553ef6bddfc70952db18875f5df1e8f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveVar </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>matvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matio_compression&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a variable to a .mat file, performing error checks along the way. </p>
<p>Once the variable is written to file, it is freed from memory, thus any further calls to Mat_VarFree on the matvar_t object will result in malloc errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matFile</td><td>a pointer to the matlab output file </td></tr>
    <tr><td class="paramname">matvar</td><td>a pointer to the matlab variable object </td></tr>
    <tr><td class="paramname">varName</td><td>a literal string that describes the variable; only used in error message output </td></tr>
    <tr><td class="paramname">comp</td><td>an enum that describes the compression strategy. Options are: MAT_COMPRESSION_NONE - no compression MAT_COMPRESSION_ZLIB - zlib compression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga85ebc44549945b1aec328349b1eb1133"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::sign </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sign of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>a number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>+/- 1 for the sign (0 if T = 0) </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d85ac5d83806da4e8b800267f9e986e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; astrohelion::sortEig </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceastrohelion.html#adad21911fcb9bf6db78b0ee09397edd1">cdouble</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceastrohelion.html#a864c99da947f1112284463c6b1136310">MatrixXRcd</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigVecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort eigenvalues. </p>
<p>This algorithm leverages three simple axioms to determine if the eigenvalues are in a consistent order. </p><pre class="fragment">1. Pairs of eigenvalues should occur in sequence ( [0,1] or [2,3], etc.) and have
a product equal to one (reciprocal pairs)

2. Eigenvalues evolve continuously along the family, thus the changes between subsequent 
eigenvalues should be small

3. Eigenvectors evolve continuously along the family, thus the dot product between subsequent
eigenvectors should be small
</pre><p>Axiom #1 is not always applicable to trajectories but is always applicable to families of periodic orbits in the CR3BP</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigVals</td><td>Vector of all eigenvalues along a family of trajectories. It is assumed that there are six eigenvalues per trajectory.</td></tr>
    <tr><td class="paramname">eigVecs</td><td>Vector of 6x6 eigenvector matrices; the eigenvectors are columns of the matrix and their order is consistent with the order of the six eigenvalues associated with the same trajectory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rearranged indices that describe the correct order of the eigenvalues/vectors </dd></dl>

</div>
</div>
<a class="anchor" id="gab351385fdf91016b664acaecbcdb820a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T astrohelion::sum </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sum all values in an array </p>
<p>For this function to work, the class must overload +=</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>an array </td></tr>
    <tr><td class="paramname">length</td><td>the number of elements in the array that can be summed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a single object representing the sum of all the elements of data. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2285370a44ae7b7a45b25b594d915eeb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T astrohelion::sum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum all values in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a vector of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>numerical data type, like int, double, long, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dd9f78c54a562d9cbaa7f28c185a1f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto astrohelion::to_underlying </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> -&gt; typename std::underlying_type&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly cast a strongly typed enumerate type to its underlying type. </p>
<p>For example, if an enum is declared as <code>enum class tp : int</code>, this function will cast any <code>tp::value</code> class to the underlying type, <code>int</code>. This is useful if you want to compare <code>int</code> values with the enum values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Object to retrieve the underlying type of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying type of e. </dd></dl>

</div>
</div>
<a class="anchor" id="gaccfdbcaf731eebb9523e329157f7a2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::wrapToPi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and angle to its equivalent between -pi and pi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An equivalent value between -pi and pi </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
