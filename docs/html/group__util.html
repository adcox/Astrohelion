<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Astrohelion: Utility</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Astrohelion
   </div>
   <div id="projectbrief">An open source multi-body astrodynamics toolkit for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab702106cf3b3e96750b6845ded4e0299"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab702106cf3b3e96750b6845ded4e0299">RESET</a>&#160;&#160;&#160;&quot;\033[0m&quot;</td></tr>
<tr class="separator:gab702106cf3b3e96750b6845ded4e0299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3b25cba33b07c303f3060fe41887f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga7b3b25cba33b07c303f3060fe41887f6">BLACK</a>&#160;&#160;&#160;&quot;\033[30m&quot;</td></tr>
<tr class="separator:ga7b3b25cba33b07c303f3060fe41887f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d23feea868a983c8c2b661e1e16972f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga8d23feea868a983c8c2b661e1e16972f">RED</a>&#160;&#160;&#160;&quot;\033[31m&quot;</td></tr>
<tr class="separator:ga8d23feea868a983c8c2b661e1e16972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbc006ea433ad708fdee3e82996e721"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gacfbc006ea433ad708fdee3e82996e721">GREEN</a>&#160;&#160;&#160;&quot;\033[32m&quot;</td></tr>
<tr class="separator:gacfbc006ea433ad708fdee3e82996e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf681265909adf3d3e8116c93c0ba179"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gabf681265909adf3d3e8116c93c0ba179">YELLOW</a>&#160;&#160;&#160;&quot;\033[33m&quot;</td></tr>
<tr class="separator:gabf681265909adf3d3e8116c93c0ba179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79d10e672abb49ad63eeaa8aaef57c38"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga79d10e672abb49ad63eeaa8aaef57c38">BLUE</a>&#160;&#160;&#160;&quot;\033[34m&quot;</td></tr>
<tr class="separator:ga79d10e672abb49ad63eeaa8aaef57c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f699060902f800f12aaae150f3a708e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga6f699060902f800f12aaae150f3a708e">MAGENTA</a>&#160;&#160;&#160;&quot;\033[35m&quot;</td></tr>
<tr class="separator:ga6f699060902f800f12aaae150f3a708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad243f93c16bc4c1d3e0a13b84421d760"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gad243f93c16bc4c1d3e0a13b84421d760">CYAN</a>&#160;&#160;&#160;&quot;\033[36m&quot;</td></tr>
<tr class="separator:gad243f93c16bc4c1d3e0a13b84421d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b537f5fa5c109d3c05c13d6b18f382"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga87b537f5fa5c109d3c05c13d6b18f382">WHITE</a>&#160;&#160;&#160;&quot;\033[37m&quot;</td></tr>
<tr class="separator:ga87b537f5fa5c109d3c05c13d6b18f382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2fe95894117165b29036718221979f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaef2fe95894117165b29036718221979f">BOLDBLACK</a>&#160;&#160;&#160;&quot;\033[1m\033[30m&quot;</td></tr>
<tr class="separator:gaef2fe95894117165b29036718221979f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab912d02c7998c3d47d05f87be4e2c920"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab912d02c7998c3d47d05f87be4e2c920">BOLDRED</a>&#160;&#160;&#160;&quot;\033[1m\033[31m&quot;</td></tr>
<tr class="separator:gab912d02c7998c3d47d05f87be4e2c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a6c893a1703c33ede7d702fe5f97c91"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4a6c893a1703c33ede7d702fe5f97c91">BOLDGREEN</a>&#160;&#160;&#160;&quot;\033[1m\033[32m&quot;</td></tr>
<tr class="separator:ga4a6c893a1703c33ede7d702fe5f97c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cec79108dfc3c61e8e32d390ec28b26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga8cec79108dfc3c61e8e32d390ec28b26">BOLDYELLOW</a>&#160;&#160;&#160;&quot;\033[1m\033[33m&quot;</td></tr>
<tr class="separator:ga8cec79108dfc3c61e8e32d390ec28b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11e77c19555cbd15bcc744ff36a18635"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga11e77c19555cbd15bcc744ff36a18635">BOLDBLUE</a>&#160;&#160;&#160;&quot;\033[1m\033[34m&quot;</td></tr>
<tr class="separator:ga11e77c19555cbd15bcc744ff36a18635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4723c5ee12cfca16e2172b57b99cb07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gac4723c5ee12cfca16e2172b57b99cb07">BOLDMAGENTA</a>&#160;&#160;&#160;&quot;\033[1m\033[35m&quot;</td></tr>
<tr class="separator:gac4723c5ee12cfca16e2172b57b99cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87af5e6363eb1913b17f24dcb60a22d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gae87af5e6363eb1913b17f24dcb60a22d">BOLDCYAN</a>&#160;&#160;&#160;&quot;\033[1m\033[36m&quot;</td></tr>
<tr class="separator:gae87af5e6363eb1913b17f24dcb60a22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4ef051614aa0bd503b0a18ee158c5d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa4ef051614aa0bd503b0a18ee158c5d7">BOLDWHITE</a>&#160;&#160;&#160;&quot;\033[1m\033[37m&quot;</td></tr>
<tr class="separator:gaa4ef051614aa0bd503b0a18ee158c5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga88ff7998e06bb38e41f325b674816d38"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga88ff7998e06bb38e41f325b674816d38">astrohelion::getCPUTime</a> ()</td></tr>
<tr class="memdesc:ga88ff7998e06bb38e41f325b674816d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current CPU time in seconds past some reference.  <a href="group__util.html#ga88ff7998e06bb38e41f325b674816d38">More...</a><br /></td></tr>
<tr class="separator:ga88ff7998e06bb38e41f325b674816d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57dc4b7dfed3611d2ef2f266d8bea62c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga57dc4b7dfed3611d2ef2f266d8bea62c">astrohelion::complexToStr</a> (std::complex&lt; double &gt; num)</td></tr>
<tr class="memdesc:ga57dc4b7dfed3611d2ef2f266d8bea62c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a complex number into a string, e.g. 1.2345 + 0.9876j.  <a href="group__util.html#ga57dc4b7dfed3611d2ef2f266d8bea62c">More...</a><br /></td></tr>
<tr class="separator:ga57dc4b7dfed3611d2ef2f266d8bea62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab475c37dc35eebe25514c0e5c7061711"><td class="memItemLeft" align="right" valign="top"><a id="gab475c37dc35eebe25514c0e5c7061711"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab475c37dc35eebe25514c0e5c7061711">astrohelion::waitForUser</a> ()</td></tr>
<tr class="memdesc:gab475c37dc35eebe25514c0e5c7061711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend operation until the user presses a key. <br /></td></tr>
<tr class="separator:gab475c37dc35eebe25514c0e5c7061711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80d7bcf787a41fe94ab45376561b615c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga80d7bcf787a41fe94ab45376561b615c">astrohelion::getNameFromSpiceID</a> (int ID)</td></tr>
<tr class="memdesc:ga80d7bcf787a41fe94ab45376561b615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a string representing the name of a spacecraft or celestial body from its SPICE ID Code.  <a href="group__util.html#ga80d7bcf787a41fe94ab45376561b615c">More...</a><br /></td></tr>
<tr class="separator:ga80d7bcf787a41fe94ab45376561b615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac537f011ec853ad6e180fe5bdd5f2ca7"><td class="memItemLeft" align="right" valign="top">SpiceInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gac537f011ec853ad6e180fe5bdd5f2ca7">astrohelion::getSpiceIDFromName</a> (const char *name)</td></tr>
<tr class="memdesc:gac537f011ec853ad6e180fe5bdd5f2ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a SPICE ID from a body name.  <a href="group__util.html#gac537f011ec853ad6e180fe5bdd5f2ca7">More...</a><br /></td></tr>
<tr class="separator:gac537f011ec853ad6e180fe5bdd5f2ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa3cc438e6d244497a9fa54748e09c3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gafa3cc438e6d244497a9fa54748e09c3e">astrohelion::checkAndReThrowSpiceErr</a> (const char *customMsg)</td></tr>
<tr class="memdesc:gafa3cc438e6d244497a9fa54748e09c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check to see if SPICE failed; if it did, throw a <a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a> with a custom error message.  <a href="group__util.html#gafa3cc438e6d244497a9fa54748e09c3e">More...</a><br /></td></tr>
<tr class="separator:gafa3cc438e6d244497a9fa54748e09c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b68c8eba2231ca76428b9414e6b1bfc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga8b68c8eba2231ca76428b9414e6b1bfc">astrohelion::resolveAngle</a> (double asinVal, double acosVal)</td></tr>
<tr class="memdesc:ga8b68c8eba2231ca76428b9414e6b1bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve double angle ambiquity from inverse trig functions.  <a href="group__util.html#ga8b68c8eba2231ca76428b9414e6b1bfc">More...</a><br /></td></tr>
<tr class="separator:ga8b68c8eba2231ca76428b9414e6b1bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e3afdce59fbddb2ee46721bad81e3c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gab1e3afdce59fbddb2ee46721bad81e3c">astrohelion::boundValue</a> (double val, double min, double max)</td></tr>
<tr class="memdesc:gab1e3afdce59fbddb2ee46721bad81e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the value of a number within some bounds.  <a href="group__util.html#gab1e3afdce59fbddb2ee46721bad81e3c">More...</a><br /></td></tr>
<tr class="separator:gab1e3afdce59fbddb2ee46721bad81e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccfdbcaf731eebb9523e329157f7a2d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaccfdbcaf731eebb9523e329157f7a2d6">astrohelion::wrapToPi</a> (double val)</td></tr>
<tr class="memdesc:gaccfdbcaf731eebb9523e329157f7a2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and angle to its equivalent between -pi and pi.  <a href="group__util.html#gaccfdbcaf731eebb9523e329157f7a2d6">More...</a><br /></td></tr>
<tr class="separator:gaccfdbcaf731eebb9523e329157f7a2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga027665ba49600ee4339eb7ccc902d28e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga027665ba49600ee4339eb7ccc902d28e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga027665ba49600ee4339eb7ccc902d28e">astrohelion::permute</a> (std::vector&lt; T &gt; values, unsigned int numSpots, std::vector&lt; unsigned int &gt; ixs, std::vector&lt; T &gt; *perms)</td></tr>
<tr class="memdesc:ga027665ba49600ee4339eb7ccc902d28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker function to compute permutations via recursion.  <a href="group__util.html#ga027665ba49600ee4339eb7ccc902d28e">More...</a><br /></td></tr>
<tr class="separator:ga027665ba49600ee4339eb7ccc902d28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9ab2020c4b72bec9c8edc9c15f1b69d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf9ab2020c4b72bec9c8edc9c15f1b69d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaf9ab2020c4b72bec9c8edc9c15f1b69d">astrohelion::permute</a> (std::vector&lt; T &gt; values, std::vector&lt; unsigned int &gt; ixs, std::vector&lt; T &gt; *perms)</td></tr>
<tr class="memdesc:gaf9ab2020c4b72bec9c8edc9c15f1b69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker function to compute permutations via recursion without repeating values.  <a href="group__util.html#gaf9ab2020c4b72bec9c8edc9c15f1b69d">More...</a><br /></td></tr>
<tr class="separator:gaf9ab2020c4b72bec9c8edc9c15f1b69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9c80b3cb13e4c9ec345faf406717d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0a9c80b3cb13e4c9ec345faf406717d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga0a9c80b3cb13e4c9ec345faf406717d6">astrohelion::aboutEquals</a> (T t1, T t2, double tol)</td></tr>
<tr class="memdesc:ga0a9c80b3cb13e4c9ec345faf406717d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two numbers are equal within a given tolerance.  <a href="group__util.html#ga0a9c80b3cb13e4c9ec345faf406717d6">More...</a><br /></td></tr>
<tr class="separator:ga0a9c80b3cb13e4c9ec345faf406717d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf5bf1474279ea4ce6bbe38cc334e09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaedf5bf1474279ea4ce6bbe38cc334e09"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaedf5bf1474279ea4ce6bbe38cc334e09">astrohelion::aboutEquals</a> (std::vector&lt; T &gt; v1, std::vector&lt; T &gt; v2, double tol)</td></tr>
<tr class="separator:gaedf5bf1474279ea4ce6bbe38cc334e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc99cd89d8f4efeaf1cf0549d65f0469"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabc99cd89d8f4efeaf1cf0549d65f0469"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gabc99cd89d8f4efeaf1cf0549d65f0469">astrohelion::concatVecs</a> (std::vector&lt; T &gt; lhs, std::vector&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:gabc99cd89d8f4efeaf1cf0549d65f0469"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate two vectors  <a href="group__util.html#gabc99cd89d8f4efeaf1cf0549d65f0469">More...</a><br /></td></tr>
<tr class="separator:gabc99cd89d8f4efeaf1cf0549d65f0469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae767ae5ffe320de3187020ebb5dcd20"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaae767ae5ffe320de3187020ebb5dcd20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaae767ae5ffe320de3187020ebb5dcd20">astrohelion::createIdentity</a> (std::vector&lt; T &gt; &amp;matRef, unsigned int size)</td></tr>
<tr class="memdesc:gaae767ae5ffe320de3187020ebb5dcd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an Identity matrix (e.g., to act as a dummy value for an STM)  <a href="group__util.html#gaae767ae5ffe320de3187020ebb5dcd20">More...</a><br /></td></tr>
<tr class="separator:gaae767ae5ffe320de3187020ebb5dcd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafb93290898836738423c62a8252205"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacafb93290898836738423c62a8252205"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gacafb93290898836738423c62a8252205">astrohelion::getSortedInd</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:gacafb93290898836738423c62a8252205"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort a vector and retrieve the indices of the sorted elements  <a href="group__util.html#gacafb93290898836738423c62a8252205">More...</a><br /></td></tr>
<tr class="separator:gacafb93290898836738423c62a8252205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf76abd538691cb4c78cd8e7dcd85f190"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf76abd538691cb4c78cd8e7dcd85f190"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gaf76abd538691cb4c78cd8e7dcd85f190">astrohelion::generatePerms</a> (std::vector&lt; T &gt; values, unsigned int n)</td></tr>
<tr class="memdesc:gaf76abd538691cb4c78cd8e7dcd85f190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all permutations of a set of n elements.  <a href="group__util.html#gaf76abd538691cb4c78cd8e7dcd85f190">More...</a><br /></td></tr>
<tr class="separator:gaf76abd538691cb4c78cd8e7dcd85f190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga731f3669b3facf50dc53a8e9c78d00f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga731f3669b3facf50dc53a8e9c78d00f8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga731f3669b3facf50dc53a8e9c78d00f8">astrohelion::generatePerms</a> (std::vector&lt; T &gt; values)</td></tr>
<tr class="memdesc:ga731f3669b3facf50dc53a8e9c78d00f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate all permutations of a set of values without repeating the values.  <a href="group__util.html#ga731f3669b3facf50dc53a8e9c78d00f8">More...</a><br /></td></tr>
<tr class="separator:ga731f3669b3facf50dc53a8e9c78d00f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a76aaf64dd10c735c67728935373945"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a76aaf64dd10c735c67728935373945"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga3a76aaf64dd10c735c67728935373945">astrohelion::imag</a> (std::vector&lt; std::complex&lt; T &gt; &gt; compVec)</td></tr>
<tr class="memdesc:ga3a76aaf64dd10c735c67728935373945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the imaginary parts of every element of a vector.  <a href="group__util.html#ga3a76aaf64dd10c735c67728935373945">More...</a><br /></td></tr>
<tr class="separator:ga3a76aaf64dd10c735c67728935373945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab351385fdf91016b664acaecbcdb820a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab351385fdf91016b664acaecbcdb820a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gab351385fdf91016b664acaecbcdb820a">astrohelion::sum</a> (T *data, int length)</td></tr>
<tr class="memdesc:gab351385fdf91016b664acaecbcdb820a"><td class="mdescLeft">&#160;</td><td class="mdescRight">sum all values in an array  <a href="group__util.html#gab351385fdf91016b664acaecbcdb820a">More...</a><br /></td></tr>
<tr class="separator:gab351385fdf91016b664acaecbcdb820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2285370a44ae7b7a45b25b594d915eeb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2285370a44ae7b7a45b25b594d915eeb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga2285370a44ae7b7a45b25b594d915eeb">astrohelion::sum</a> (std::vector&lt; T &gt; data)</td></tr>
<tr class="memdesc:ga2285370a44ae7b7a45b25b594d915eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum all values in a vector.  <a href="group__util.html#ga2285370a44ae7b7a45b25b594d915eeb">More...</a><br /></td></tr>
<tr class="separator:ga2285370a44ae7b7a45b25b594d915eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1ff60d4af4abee3c46c2895e200e7c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac1ff60d4af4abee3c46c2895e200e7c3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#gac1ff60d4af4abee3c46c2895e200e7c3">astrohelion::mean</a> (T *data, int length)</td></tr>
<tr class="memdesc:gac1ff60d4af4abee3c46c2895e200e7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean (average) of an array of data.  <a href="group__util.html#gac1ff60d4af4abee3c46c2895e200e7c3">More...</a><br /></td></tr>
<tr class="separator:gac1ff60d4af4abee3c46c2895e200e7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga145908792689d801e6f32baf855972bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga145908792689d801e6f32baf855972bc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga145908792689d801e6f32baf855972bc">astrohelion::mean</a> (std::vector&lt; T &gt; data)</td></tr>
<tr class="memdesc:ga145908792689d801e6f32baf855972bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean (average) of a vector of data.  <a href="group__util.html#ga145908792689d801e6f32baf855972bc">More...</a><br /></td></tr>
<tr class="separator:ga145908792689d801e6f32baf855972bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b14977397b33216fba702b2eafa8880"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6b14977397b33216fba702b2eafa8880"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga6b14977397b33216fba702b2eafa8880">astrohelion::real</a> (std::vector&lt; std::complex&lt; T &gt; &gt; compVec)</td></tr>
<tr class="memdesc:ga6b14977397b33216fba702b2eafa8880"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real parts of every element of a vector.  <a href="group__util.html#ga6b14977397b33216fba702b2eafa8880">More...</a><br /></td></tr>
<tr class="separator:ga6b14977397b33216fba702b2eafa8880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ebc44549945b1aec328349b1eb1133"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga85ebc44549945b1aec328349b1eb1133"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga85ebc44549945b1aec328349b1eb1133">astrohelion::sign</a> (T num)</td></tr>
<tr class="memdesc:ga85ebc44549945b1aec328349b1eb1133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sign of a number.  <a href="group__util.html#ga85ebc44549945b1aec328349b1eb1133">More...</a><br /></td></tr>
<tr class="separator:ga85ebc44549945b1aec328349b1eb1133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd008250f4c2c8611e7d2f8031e6024"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7dd008250f4c2c8611e7d2f8031e6024"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga7dd008250f4c2c8611e7d2f8031e6024">astrohelion::compareMagnitude</a> (std::complex&lt; T &gt; lhs, std::complex&lt; T &gt; rhs)</td></tr>
<tr class="memdesc:ga7dd008250f4c2c8611e7d2f8031e6024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two complex numbers by comparing their magnitudes.  <a href="group__util.html#ga7dd008250f4c2c8611e7d2f8031e6024">More...</a><br /></td></tr>
<tr class="separator:ga7dd008250f4c2c8611e7d2f8031e6024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dd9f78c54a562d9cbaa7f28c185a1f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6dd9f78c54a562d9cbaa7f28c185a1f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__util.html#ga6dd9f78c54a562d9cbaa7f28c185a1f7">astrohelion::to_underlying</a> (T e) -&gt; typename std::underlying_type&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga6dd9f78c54a562d9cbaa7f28c185a1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly cast a strongly typed enumerate type to its underlying type.  <a href="group__util.html#ga6dd9f78c54a562d9cbaa7f28c185a1f7">More...</a><br /></td></tr>
<tr class="separator:ga6dd9f78c54a562d9cbaa7f28c185a1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
General Utility Functions</h2></td></tr>
<tr class="memitem:ga4c5aa3086bea7fb6f2007c10a3c058a4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4c5aa3086bea7fb6f2007c10a3c058a4">astrohelion::dateToEphemerisTime</a> (const char *pDate)</td></tr>
<tr class="memdesc:ga4c5aa3086bea7fb6f2007c10a3c058a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a date to ephemeris time  <a href="group__util.html#ga4c5aa3086bea7fb6f2007c10a3c058a4">More...</a><br /></td></tr>
<tr class="separator:ga4c5aa3086bea7fb6f2007c10a3c058a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga182088a2e80b199fe5b0480e4b7eccaf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga182088a2e80b199fe5b0480e4b7eccaf">astrohelion::gregorianToJulian</a> (double yr, double mo, double d, double h, double m, double s)</td></tr>
<tr class="memdesc:ga182088a2e80b199fe5b0480e4b7eccaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a gregorian date to Julian Date.  <a href="group__util.html#ga182088a2e80b199fe5b0480e4b7eccaf">More...</a><br /></td></tr>
<tr class="separator:ga182088a2e80b199fe5b0480e4b7eccaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61481cb7f8eba07060c00e3eb2b43fbe"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga61481cb7f8eba07060c00e3eb2b43fbe">astrohelion::dateToGST</a> (double yr, double mo, double d, double h, double m, double s)</td></tr>
<tr class="memdesc:ga61481cb7f8eba07060c00e3eb2b43fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the Greenwich Sidereal Time (i.e., angle) at the specified date.  <a href="group__util.html#ga61481cb7f8eba07060c00e3eb2b43fbe">More...</a><br /></td></tr>
<tr class="separator:ga61481cb7f8eba07060c00e3eb2b43fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b0a2fd073d6088493c4265d3f6b8267"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga7b0a2fd073d6088493c4265d3f6b8267">astrohelion::familyCont_LS</a> (int indVarIx, double nextInd, std::vector&lt; int &gt; depVars, std::vector&lt; double &gt; varHistory)</td></tr>
<tr class="memdesc:ga7b0a2fd073d6088493c4265d3f6b8267"><td class="mdescLeft">&#160;</td><td class="mdescRight">use least squares to predict new values of variables in a continuation process  <a href="group__util.html#ga7b0a2fd073d6088493c4265d3f6b8267">More...</a><br /></td></tr>
<tr class="separator:ga7b0a2fd073d6088493c4265d3f6b8267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95726b58be1524bab6b7e58647d41363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga95726b58be1524bab6b7e58647d41363">astrohelion::getMirrorMat</a> (<a class="el" href="namespaceastrohelion.html#a8347f74809e68d46715a1fd9e28e2f86">Mirror_tp</a> mirrorType)</td></tr>
<tr class="memdesc:ga95726b58be1524bab6b7e58647d41363"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct a matrix to mirror a 6-d state over the specified plane or axis  <a href="group__util.html#ga95726b58be1524bab6b7e58647d41363">More...</a><br /></td></tr>
<tr class="separator:ga95726b58be1524bab6b7e58647d41363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga777cfd117e90b9f00c95ae72116634ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga777cfd117e90b9f00c95ae72116634ea">astrohelion::sortEig</a> (std::vector&lt; <a class="el" href="namespaceastrohelion.html#adad21911fcb9bf6db78b0ee09397edd1">cdouble</a> &gt; eigVals, std::vector&lt; <a class="el" href="namespaceastrohelion.html#a864c99da947f1112284463c6b1136310">MatrixXRcd</a> &gt; eigVecs)</td></tr>
<tr class="memdesc:ga777cfd117e90b9f00c95ae72116634ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort eigenvalues.  <a href="group__util.html#ga777cfd117e90b9f00c95ae72116634ea">More...</a><br /></td></tr>
<tr class="separator:ga777cfd117e90b9f00c95ae72116634ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15db36118c3e03530b9997630b1e4b89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga15db36118c3e03530b9997630b1e4b89">astrohelion::getStabilityIndex</a> (std::vector&lt; <a class="el" href="namespaceastrohelion.html#adad21911fcb9bf6db78b0ee09397edd1">cdouble</a> &gt; eigs)</td></tr>
<tr class="memdesc:ga15db36118c3e03530b9997630b1e4b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stability index of a periodic orbit from a set of eigenvalues.  <a href="group__util.html#ga15db36118c3e03530b9997630b1e4b89">More...</a><br /></td></tr>
<tr class="separator:ga15db36118c3e03530b9997630b1e4b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0f5dcd605acc6d0212181a69746844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classastrohelion_1_1_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga3c0f5dcd605acc6d0212181a69746844">astrohelion::interpPointAtTime</a> (const <a class="el" href="classastrohelion_1_1_arcset.html">Arcset</a> *traj, double t)</td></tr>
<tr class="memdesc:ga3c0f5dcd605acc6d0212181a69746844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use numerical integration to find a node on a trajectory at the specified time.  <a href="group__util.html#ga3c0f5dcd605acc6d0212181a69746844">More...</a><br /></td></tr>
<tr class="separator:ga3c0f5dcd605acc6d0212181a69746844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97f536e181052b5b1b3ebbd9a3a1d4f4"><td class="memItemLeft" align="right" valign="top"><a id="ga97f536e181052b5b1b3ebbd9a3a1d4f4"></a>
<a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td><td class="memItemRight" valign="bottom"><b>astrohelion::solveAX_eq_B</b> (<a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>, <a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>)</td></tr>
<tr class="separator:ga97f536e181052b5b1b3ebbd9a3a1d4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Orbit Determination</h2></td></tr>
<tr class="memitem:gaa1a6596be33ebd2549ab95f13ab81474"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa1a6596be33ebd2549ab95f13ab81474">astrohelion::getSpherical</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:gaa1a6596be33ebd2549ab95f13ab81474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine a set of spherical coordinates the describe the position vector specified by x, y, and z.  <a href="group__util.html#gaa1a6596be33ebd2549ab95f13ab81474">More...</a><br /></td></tr>
<tr class="separator:gaa1a6596be33ebd2549ab95f13ab81474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc509230677aaf94f75d70edf69f89c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga2cc509230677aaf94f75d70edf69f89c">astrohelion::inert2LocalTangent</a> (std::vector&lt; double &gt; inertPos, double lat, double lon, double theta_mer)</td></tr>
<tr class="memdesc:ga2cc509230677aaf94f75d70edf69f89c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert inertial coordinates to local tangent coordinates.  <a href="group__util.html#ga2cc509230677aaf94f75d70edf69f89c">More...</a><br /></td></tr>
<tr class="separator:ga2cc509230677aaf94f75d70edf69f89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d6ccbe0327d00b4e2e0ad30cbf0e744"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4d6ccbe0327d00b4e2e0ad30cbf0e744">astrohelion::localTangent2Inert</a> (std::vector&lt; double &gt; localPos, double lat, double lon, double theta_mer)</td></tr>
<tr class="memdesc:ga4d6ccbe0327d00b4e2e0ad30cbf0e744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert local tangent coordinates to inertial coordinates.  <a href="group__util.html#ga4d6ccbe0327d00b4e2e0ad30cbf0e744">More...</a><br /></td></tr>
<tr class="separator:ga4d6ccbe0327d00b4e2e0ad30cbf0e744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0479c696fb8fbd70d74d64adc43af25d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga0479c696fb8fbd70d74d64adc43af25d">astrohelion::azEl2LocalTangent</a> (double s, double az, double el)</td></tr>
<tr class="memdesc:ga0479c696fb8fbd70d74d64adc43af25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local tangent coordinates of an object given its azimuth, elevation, and range.  <a href="group__util.html#ga0479c696fb8fbd70d74d64adc43af25d">More...</a><br /></td></tr>
<tr class="separator:ga0479c696fb8fbd70d74d64adc43af25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Standard Output</h2></td></tr>
<tr class="memitem:gac3b46b081f51bdb325b1e196564183ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gac3b46b081f51bdb325b1e196564183ae">astrohelion::printVerb</a> (bool verbose, const char *format,...)</td></tr>
<tr class="memdesc:gac3b46b081f51bdb325b1e196564183ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper function to print a message.  <a href="group__util.html#gac3b46b081f51bdb325b1e196564183ae">More...</a><br /></td></tr>
<tr class="separator:gac3b46b081f51bdb325b1e196564183ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c62b88d77cf0935f4d74187423143e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga0c62b88d77cf0935f4d74187423143e6">astrohelion::printErr</a> (const char *format,...)</td></tr>
<tr class="memdesc:ga0c62b88d77cf0935f4d74187423143e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an error message to the standard output in red.  <a href="group__util.html#ga0c62b88d77cf0935f4d74187423143e6">More...</a><br /></td></tr>
<tr class="separator:ga0c62b88d77cf0935f4d74187423143e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48bfcd6112b39e450fd33621c7a67b00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga48bfcd6112b39e450fd33621c7a67b00">astrohelion::printWarn</a> (const char *format,...)</td></tr>
<tr class="memdesc:ga48bfcd6112b39e450fd33621c7a67b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a warning messate to the standard output in yellow.  <a href="group__util.html#ga48bfcd6112b39e450fd33621c7a67b00">More...</a><br /></td></tr>
<tr class="separator:ga48bfcd6112b39e450fd33621c7a67b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0aa1c81b491a8022db82871f168bbec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gad0aa1c81b491a8022db82871f168bbec">astrohelion::printColor</a> (const char *color, const char *format,...)</td></tr>
<tr class="memdesc:gad0aa1c81b491a8022db82871f168bbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to the standard output using an ASCII escape-type color.  <a href="group__util.html#gad0aa1c81b491a8022db82871f168bbec">More...</a><br /></td></tr>
<tr class="separator:gad0aa1c81b491a8022db82871f168bbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa97e4e3ab8efb5ae96fa6d0d8cf018c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa97e4e3ab8efb5ae96fa6d0d8cf018c3">astrohelion::printVerbColor</a> (bool verbose, const char *color, const char *format,...)</td></tr>
<tr class="memdesc:gaa97e4e3ab8efb5ae96fa6d0d8cf018c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to the standard output using an ASCII escape-type color.  <a href="group__util.html#gaa97e4e3ab8efb5ae96fa6d0d8cf018c3">More...</a><br /></td></tr>
<tr class="separator:gaa97e4e3ab8efb5ae96fa6d0d8cf018c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
File I/O</h2></td></tr>
<tr class="memitem:ga553ef6bddfc70952db18875f5df1e8f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga553ef6bddfc70952db18875f5df1e8f2">astrohelion::saveVar</a> (mat_t *matFile, matvar_t *matvar, const char *varName, matio_compression comp)</td></tr>
<tr class="memdesc:ga553ef6bddfc70952db18875f5df1e8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a variable to a .mat file, performing error checks along the way.  <a href="group__util.html#ga553ef6bddfc70952db18875f5df1e8f2">More...</a><br /></td></tr>
<tr class="separator:ga553ef6bddfc70952db18875f5df1e8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4be30e012cbdb013c3fa4658e9131e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga4be30e012cbdb013c3fa4658e9131e16">astrohelion::saveDoubleToFile</a> (mat_t *matfp, const char *varName, double data)</td></tr>
<tr class="memdesc:ga4be30e012cbdb013c3fa4658e9131e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a single double-precision value to a Matlab file.  <a href="group__util.html#ga4be30e012cbdb013c3fa4658e9131e16">More...</a><br /></td></tr>
<tr class="separator:ga4be30e012cbdb013c3fa4658e9131e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c3045a2c2270ba2e6e2ff0ed671d72c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga3c3045a2c2270ba2e6e2ff0ed671d72c">astrohelion::saveMatrixToFile</a> (const char *filename, const char *varName, std::vector&lt; double &gt; data, size_t rows, size_t cols)</td></tr>
<tr class="memdesc:ga3c3045a2c2270ba2e6e2ff0ed671d72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a matrix of data to a Matlab .mat file.  <a href="group__util.html#ga3c3045a2c2270ba2e6e2ff0ed671d72c">More...</a><br /></td></tr>
<tr class="separator:ga3c3045a2c2270ba2e6e2ff0ed671d72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15cf53228c93a84457dffacd64475a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga15cf53228c93a84457dffacd64475a56">astrohelion::saveMatrixToFile</a> (mat_t *matfp, const char *varName, std::vector&lt; double &gt; data, size_t rows, size_t cols)</td></tr>
<tr class="memdesc:ga15cf53228c93a84457dffacd64475a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a matrix of data to an open matlab .mat file.  <a href="group__util.html#ga15cf53228c93a84457dffacd64475a56">More...</a><br /></td></tr>
<tr class="separator:ga15cf53228c93a84457dffacd64475a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8dbbfc9dd4aaa93bc5efcaace5933de"><td class="memItemLeft" align="right" valign="top"><a id="gae8dbbfc9dd4aaa93bc5efcaace5933de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>astrohelion::saveStringToFile</b> (mat_t *matfp, const char *varName, std::string text, const int strlen)</td></tr>
<tr class="separator:gae8dbbfc9dd4aaa93bc5efcaace5933de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89fcd44ede02561762c5c005b35dab48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga89fcd44ede02561762c5c005b35dab48">astrohelion::readMatrixFromMat</a> (const char *filename, const char *varName)</td></tr>
<tr class="memdesc:ga89fcd44ede02561762c5c005b35dab48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix of doubles from a .mat file.  <a href="group__util.html#ga89fcd44ede02561762c5c005b35dab48">More...</a><br /></td></tr>
<tr class="separator:ga89fcd44ede02561762c5c005b35dab48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf353962161fbf0c85dd7313165903068"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaf353962161fbf0c85dd7313165903068">astrohelion::readDoubleFromMat</a> (mat_t *matFile, const char *varName)</td></tr>
<tr class="memdesc:gaf353962161fbf0c85dd7313165903068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a double from a mat file.  <a href="group__util.html#gaf353962161fbf0c85dd7313165903068">More...</a><br /></td></tr>
<tr class="separator:gaf353962161fbf0c85dd7313165903068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0e3858d1fdc7289cac1f8e09cac9ef8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#gaa0e3858d1fdc7289cac1f8e09cac9ef8">astrohelion::readStringFromMat</a> (mat_t *matFile, const char *varName, matio_types aType, matio_classes aClass)</td></tr>
<tr class="memdesc:gaa0e3858d1fdc7289cac1f8e09cac9ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string from a matlab file.  <a href="group__util.html#gaa0e3858d1fdc7289cac1f8e09cac9ef8">More...</a><br /></td></tr>
<tr class="separator:gaa0e3858d1fdc7289cac1f8e09cac9ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e325e7da3ac2e72d23f4998a58e9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__util.html#ga15e325e7da3ac2e72d23f4998a58e9be">astrohelion::toCSV</a> (<a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a> m, const char *filename)</td></tr>
<tr class="memdesc:ga15e325e7da3ac2e72d23f4998a58e9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a matrix as a CSV file to be read by Excel or Matlab.  <a href="group__util.html#ga15e325e7da3ac2e72d23f4998a58e9be">More...</a><br /></td></tr>
<tr class="separator:ga15e325e7da3ac2e72d23f4998a58e9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga015a9ff07ff319121d5ef61779a61061"><td class="memItemLeft" align="right" valign="top"><a id="ga015a9ff07ff319121d5ef61779a61061"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>astrohelion::fileExists</b> (const char *filename)</td></tr>
<tr class="separator:ga015a9ff07ff319121d5ef61779a61061"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Contains all utility objects and methods </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7b3b25cba33b07c303f3060fe41887f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b3b25cba33b07c303f3060fe41887f6">&#9670;&nbsp;</a></span>BLACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLACK&#160;&#160;&#160;&quot;\033[30m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text black </p>

</div>
</div>
<a id="ga79d10e672abb49ad63eeaa8aaef57c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79d10e672abb49ad63eeaa8aaef57c38">&#9670;&nbsp;</a></span>BLUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BLUE&#160;&#160;&#160;&quot;\033[34m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text blue </p>

</div>
</div>
<a id="gaef2fe95894117165b29036718221979f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef2fe95894117165b29036718221979f">&#9670;&nbsp;</a></span>BOLDBLACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDBLACK&#160;&#160;&#160;&quot;\033[1m\033[30m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and black </p>

</div>
</div>
<a id="ga11e77c19555cbd15bcc744ff36a18635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11e77c19555cbd15bcc744ff36a18635">&#9670;&nbsp;</a></span>BOLDBLUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDBLUE&#160;&#160;&#160;&quot;\033[1m\033[34m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and blue </p>

</div>
</div>
<a id="gae87af5e6363eb1913b17f24dcb60a22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae87af5e6363eb1913b17f24dcb60a22d">&#9670;&nbsp;</a></span>BOLDCYAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDCYAN&#160;&#160;&#160;&quot;\033[1m\033[36m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and cyan </p>

</div>
</div>
<a id="ga4a6c893a1703c33ede7d702fe5f97c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a6c893a1703c33ede7d702fe5f97c91">&#9670;&nbsp;</a></span>BOLDGREEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDGREEN&#160;&#160;&#160;&quot;\033[1m\033[32m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and green </p>

</div>
</div>
<a id="gac4723c5ee12cfca16e2172b57b99cb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4723c5ee12cfca16e2172b57b99cb07">&#9670;&nbsp;</a></span>BOLDMAGENTA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDMAGENTA&#160;&#160;&#160;&quot;\033[1m\033[35m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and magenta </p>

</div>
</div>
<a id="gab912d02c7998c3d47d05f87be4e2c920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab912d02c7998c3d47d05f87be4e2c920">&#9670;&nbsp;</a></span>BOLDRED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDRED&#160;&#160;&#160;&quot;\033[1m\033[31m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and red </p>

</div>
</div>
<a id="gaa4ef051614aa0bd503b0a18ee158c5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4ef051614aa0bd503b0a18ee158c5d7">&#9670;&nbsp;</a></span>BOLDWHITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDWHITE&#160;&#160;&#160;&quot;\033[1m\033[37m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and white </p>

</div>
</div>
<a id="ga8cec79108dfc3c61e8e32d390ec28b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cec79108dfc3c61e8e32d390ec28b26">&#9670;&nbsp;</a></span>BOLDYELLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BOLDYELLOW&#160;&#160;&#160;&quot;\033[1m\033[33m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text bold and yellow </p>

</div>
</div>
<a id="gad243f93c16bc4c1d3e0a13b84421d760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad243f93c16bc4c1d3e0a13b84421d760">&#9670;&nbsp;</a></span>CYAN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CYAN&#160;&#160;&#160;&quot;\033[36m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text cyan </p>

</div>
</div>
<a id="gacfbc006ea433ad708fdee3e82996e721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfbc006ea433ad708fdee3e82996e721">&#9670;&nbsp;</a></span>GREEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GREEN&#160;&#160;&#160;&quot;\033[32m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text green </p>

</div>
</div>
<a id="ga6f699060902f800f12aaae150f3a708e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f699060902f800f12aaae150f3a708e">&#9670;&nbsp;</a></span>MAGENTA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAGENTA&#160;&#160;&#160;&quot;\033[35m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text magenta </p>

</div>
</div>
<a id="ga8d23feea868a983c8c2b661e1e16972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d23feea868a983c8c2b661e1e16972f">&#9670;&nbsp;</a></span>RED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RED&#160;&#160;&#160;&quot;\033[31m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text red </p>

</div>
</div>
<a id="gab702106cf3b3e96750b6845ded4e0299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab702106cf3b3e96750b6845ded4e0299">&#9670;&nbsp;</a></span>RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RESET&#160;&#160;&#160;&quot;\033[0m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset ASCII text to default values </p>

</div>
</div>
<a id="ga87b537f5fa5c109d3c05c13d6b18f382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b537f5fa5c109d3c05c13d6b18f382">&#9670;&nbsp;</a></span>WHITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WHITE&#160;&#160;&#160;&quot;\033[37m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text white </p>

</div>
</div>
<a id="gabf681265909adf3d3e8116c93c0ba179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf681265909adf3d3e8116c93c0ba179">&#9670;&nbsp;</a></span>YELLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define YELLOW&#160;&#160;&#160;&quot;\033[33m&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make ASCII text yellow </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0a9c80b3cb13e4c9ec345faf406717d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a9c80b3cb13e4c9ec345faf406717d6">&#9670;&nbsp;</a></span>aboutEquals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::aboutEquals </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if two numbers are equal within a given tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t1</td><td>a number </td></tr>
    <tr><td class="paramname">t2</td><td>another number </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the absolute value of the difference between t1 and t2 is less than the tolerance </dd></dl>

</div>
</div>
<a id="gaedf5bf1474279ea4ce6bbe38cc334e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedf5bf1474279ea4ce6bbe38cc334e09">&#9670;&nbsp;</a></span>aboutEquals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::aboutEquals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>@ brief Check if two vectors are equal to a given tolerance </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>a vector </td></tr>
    <tr><td class="paramname">v2</td><td>another vector </td></tr>
    <tr><td class="paramname">tol</td><td>the tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if v1 and v2 are the same size and their corresponding elements differ by less than the tolerance </dd></dl>

</div>
</div>
<a id="ga0479c696fb8fbd70d74d64adc43af25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0479c696fb8fbd70d74d64adc43af25d">&#9670;&nbsp;</a></span>azEl2LocalTangent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::azEl2LocalTangent </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>az</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>el</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local tangent coordinates of an object given its azimuth, elevation, and range. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>range distance </td></tr>
    <tr><td class="paramname">az</td><td>azimuth, measured from North toward East, radians </td></tr>
    <tr><td class="paramname">el</td><td>elevation, measured from local horizontal, radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[r_E, r_N, r_Z] the position of the object in local tangent coordinates (East, North, Up), units that match the input range </dd></dl>

</div>
</div>
<a id="gab1e3afdce59fbddb2ee46721bad81e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1e3afdce59fbddb2ee46721bad81e3c">&#9670;&nbsp;</a></span>boundValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::boundValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the value of a number within some bounds. </p>
<p>This is particularly useful for arguments for inverse trig functions: small numerical errors may result in arccos(1 + eps) or arsin(-1 - eps) where eps is some small value. The resulting inverse trig function will be invalide and return NAN. In this case, use boundValue(value, -1, 1) to ensure that the argument inside the trig function is between -1 and 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to bound </td></tr>
    <tr><td class="paramname">min</td><td>minimum allowable value </td></tr>
    <tr><td class="paramname">max</td><td>maximum allowable value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value if it is within the bounds, or the min/max bound if val is outside the bounds. </dd></dl>

</div>
</div>
<a id="gafa3cc438e6d244497a9fa54748e09c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa3cc438e6d244497a9fa54748e09c3e">&#9670;&nbsp;</a></span>checkAndReThrowSpiceErr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::checkAndReThrowSpiceErr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>customMsg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check to see if SPICE failed; if it did, throw a <a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a> with a custom error message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">customMsg</td><td>A message for the <a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if an error occured </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7dd008250f4c2c8611e7d2f8031e6024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dd008250f4c2c8611e7d2f8031e6024">&#9670;&nbsp;</a></span>compareMagnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool astrohelion::compareMagnitude </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two complex numbers by comparing their magnitudes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td></td></tr>
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not the magnitude of lhs is less than the magnitude of rhs </dd></dl>

</div>
</div>
<a id="ga57dc4b7dfed3611d2ef2f266d8bea62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57dc4b7dfed3611d2ef2f266d8bea62c">&#9670;&nbsp;</a></span>complexToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string astrohelion::complexToStr </td>
          <td>(</td>
          <td class="paramtype">std::complex&lt; double &gt;&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn a complex number into a string, e.g. 1.2345 + 0.9876j. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>a complex number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the complex number as a string </dd></dl>

</div>
</div>
<a id="gabc99cd89d8f4efeaf1cf0549d65f0469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc99cd89d8f4efeaf1cf0549d65f0469">&#9670;&nbsp;</a></span>concatVecs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::concatVecs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>concatenate two vectors </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>the left-hand-side vector </td></tr>
    <tr><td class="paramname">rhs</td><td>the righ-hand-side vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new vector that includes both input vectors in order, i.e. [lhs, rhs] </dd></dl>

</div>
</div>
<a id="gaae767ae5ffe320de3187020ebb5dcd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae767ae5ffe320de3187020ebb5dcd20">&#9670;&nbsp;</a></span>createIdentity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::createIdentity </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>matRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an Identity matrix (e.g., to act as a dummy value for an STM) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matRef</td><td>reference to a vector that stores matrix elements. Any nonzero elements are overwritten </td></tr>
    <tr><td class="paramname">size</td><td>side length of the matrix (e.g., the size of a 6x6 matrix is 6) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c5aa3086bea7fb6f2007c10a3c058a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c5aa3086bea7fb6f2007c10a3c058a4">&#9670;&nbsp;</a></span>dateToEphemerisTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::dateToEphemerisTime </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pDate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert a date to ephemeris time </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pDate</td><td>a string representing the date. The string can be formatted in one of two ways. First, a Gregorian-style date: 'YYYY/MM/DD HH:II:SS' (UTC, 24-hour clock); The time 'HH:II:SS' can be ommited, and the function will assume the time is 0:0:00 Second, a Julian date (UTC) can be input with the format 'jd #' where '#' represents the Julian date.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the J2000 ephemeris time, or number of seconds after Jan 1, 2000 at 0:0:00 UTC. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the SPICE kernels cannot be loaded: the kernel names and filepaths are located in the settings XML file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61481cb7f8eba07060c00e3eb2b43fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61481cb7f8eba07060c00e3eb2b43fbe">&#9670;&nbsp;</a></span>dateToGST()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::dateToGST </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the Greenwich Sidereal Time (i.e., angle) at the specified date. </p>
<p>Input date must be in UT1 time (always within +/- 0.9 seconds of UTC thanks to leapseconds)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yr</td><td>Year </td></tr>
    <tr><td class="paramname">mo</td><td>Month (Jan = 1, ..., Dec = 12) </td></tr>
    <tr><td class="paramname">d</td><td>Day of mongth </td></tr>
    <tr><td class="paramname">h</td><td>Hour (24-hr clock) </td></tr>
    <tr><td class="paramname">m</td><td>minute </td></tr>
    <tr><td class="paramname">s</td><td>second </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Greenwich Sidereal Time (GST) in radians at the specified date </dd></dl>

</div>
</div>
<a id="ga7b0a2fd073d6088493c4265d3f6b8267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b0a2fd073d6088493c4265d3f6b8267">&#9670;&nbsp;</a></span>familyCont_LS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::familyCont_LS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indVarIx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nextInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>depVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>varHistory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use least squares to predict new values of variables in a continuation process </p>
<p>This function uses a 2nd-order polynomial fit to predict a set of dependent variables using past relationships between an independent variable and the dependent variables. The number of points considered in those past relationships can be adjusted to vary the "stiffness" of the fit.</p>
<p>Ocasionally the 2nd-order fit does not work well and we encounter a singular (or very near singular) matrix. In this case, the algorithm will apply linear regression, which generally solves the problem and results in a safe inversion.</p>
<p>For all these inputs, the "state vector" must take the following form: [x, y, z, xdot, ydot, zdot, Period, Jacobi Constant]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indVarIx</td><td>the index of the state variable to use as the indpendent variable </td></tr>
    <tr><td class="paramname">nextInd</td><td>The next value of the independent variable </td></tr>
    <tr><td class="paramname">depVars</td><td>a vector specifying the indices of the states that will be dependent variables. The algorithm will predict fugure values for these variables based on how they have changed with the independent variable. </td></tr>
    <tr><td class="paramname">varHistory</td><td>a vector representing an n x 8 matrix which contains information about previous states, period, and JC. n should be at least<ol type="1">
<li>If it is larger than MemSize, only the first set of MemSize rows will be used.</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an 8-element vector with predictions for the dependent variables. If a particular variable has not been predicted, its place will be kept with a NAN value.</dd></dl>
<p>An example may make things more clear:</p>
<p>Say I am continuing a family and am using x as the natural parameter in the continuation. indVarIx would be 0 to represent x. We input the value of x for the next orbit in the family (nextInd) and specify which variables (from the 8-element "state") we would like to have predicted by least-squares. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the <code>varHistory</code> vector contains fewer than 8 elements or if the <code>depVars</code> vector has no data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf76abd538691cb4c78cd8e7dcd85f190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf76abd538691cb4c78cd8e7dcd85f190">&#9670;&nbsp;</a></span>generatePerms() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::generatePerms </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all permutations of a set of n elements. </p>
<p>Each of the n elements can contain any of the values stored in the values vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>a vector containing all possible values for each element </td></tr>
    <tr><td class="paramname">n</td><td>the number of elements in the permutation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing all permutations, in row-major order where each row is a separate permutation </dd></dl>

</div>
</div>
<a id="ga731f3669b3facf50dc53a8e9c78d00f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga731f3669b3facf50dc53a8e9c78d00f8">&#9670;&nbsp;</a></span>generatePerms() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::generatePerms </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate all permutations of a set of values without repeating the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>the set of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing all permutations, in row-major order where each row is a seperate permutation of <code>values</code> </dd></dl>

</div>
</div>
<a id="ga88ff7998e06bb38e41f325b674816d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88ff7998e06bb38e41f325b674816d38">&#9670;&nbsp;</a></span>getCPUTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::getCPUTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current CPU time in seconds past some reference. </p>
<dl class="section return"><dt>Returns</dt><dd>the current CPU time in seconds past some reference </dd></dl>

</div>
</div>
<a id="ga95726b58be1524bab6b7e58647d41363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95726b58be1524bab6b7e58647d41363">&#9670;&nbsp;</a></span>getMirrorMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a> astrohelion::getMirrorMat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a8347f74809e68d46715a1fd9e28e2f86">Mirror_tp</a>&#160;</td>
          <td class="paramname"><em>mirrorType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct a matrix to mirror a 6-d state over the specified plane or axis </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mirrorType</td><td>describes how to mirror a 6-d state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 6x6 matrix that will mirror a 6-d state over the specified plane or axis </dd></dl>

</div>
</div>
<a id="ga80d7bcf787a41fe94ab45376561b615c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80d7bcf787a41fe94ab45376561b615c">&#9670;&nbsp;</a></span>getNameFromSpiceID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string astrohelion::getNameFromSpiceID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a string representing the name of a spacecraft or celestial body from its SPICE ID Code. </p>
<p>For a list of SPICE IDs, see the <a href="http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/req/naif_ids.html">NAIF ID Page</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ID</td><td>Integer ID Code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the body or satellite </dd></dl>

</div>
</div>
<a id="gacafb93290898836738423c62a8252205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacafb93290898836738423c62a8252205">&#9670;&nbsp;</a></span>getSortedInd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; astrohelion::getSortedInd </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sort a vector and retrieve the indices of the sorted elements </p>
<p>Takes a copy of a vector and sorts it, retaining the original indices of the elements. For example, sorting {1,3,2} would return the indices {0,2,1}.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector to sort </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the indices of the sorted elements </dd></dl>

</div>
</div>
<a id="gaa1a6596be33ebd2549ab95f13ab81474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1a6596be33ebd2549ab95f13ab81474">&#9670;&nbsp;</a></span>getSpherical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::getSpherical </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine a set of spherical coordinates the describe the position vector specified by x, y, and z. </p>
<p>The longitude angle measures in the in-plane angle, measured from the +x-axis in a right-handed rotationg about the +z-axis. Latitude represents the out-of-plane angle measured from the xy-plane, with positive angles representing points with positive z-coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-coordinate </td></tr>
    <tr><td class="paramname">y</td><td>y-coordinate </td></tr>
    <tr><td class="paramname">z</td><td>z-coordinate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing {lat, long, R} in radians and the distance units of x, y, and z. Latitude takes a value between -pi/2 and pi/2 while longitude takes a value between -pi and pi </dd></dl>

</div>
</div>
<a id="gac537f011ec853ad6e180fe5bdd5f2ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac537f011ec853ad6e180fe5bdd5f2ca7">&#9670;&nbsp;</a></span>getSpiceIDFromName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SpiceInt astrohelion::getSpiceIDFromName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a SPICE ID from a body name. </p>
<p>Body names are case insensitive and leading/trailing spaces are not important. However, when the name is made up of more than word, they must be separated by at least one space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>body name to be translated to a SPICE ID code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a SPICE integer ID code </dd></dl>

</div>
</div>
<a id="ga15db36118c3e03530b9997630b1e4b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15db36118c3e03530b9997630b1e4b89">&#9670;&nbsp;</a></span>getStabilityIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::getStabilityIndex </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceastrohelion.html#adad21911fcb9bf6db78b0ee09397edd1">cdouble</a> &gt;&#160;</td>
          <td class="paramname"><em>eigs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the stability index of a periodic orbit from a set of eigenvalues. </p>
<p>This algorithm assumes the orbit is periodic and that the eigenvalues have been sorted (so they come in pairs).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigs</td><td>A 6-element vector of eigenvalues associated with a periodic orbit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stability index, or NAN if no real, reciprocal eigenvalue pair is found </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>eigs</code> does not have six elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga182088a2e80b199fe5b0480e4b7eccaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga182088a2e80b199fe5b0480e4b7eccaf">&#9670;&nbsp;</a></span>gregorianToJulian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::gregorianToJulian </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a gregorian date to Julian Date. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yr</td><td>Year </td></tr>
    <tr><td class="paramname">mo</td><td>Month (Jan = 1, ..., Dec = 12) </td></tr>
    <tr><td class="paramname">d</td><td>Day of mongth </td></tr>
    <tr><td class="paramname">h</td><td>Hour (24-hr clock) </td></tr>
    <tr><td class="paramname">m</td><td>minute </td></tr>
    <tr><td class="paramname">s</td><td>second </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Julian Date (days) </dd></dl>

</div>
</div>
<a id="ga3a76aaf64dd10c735c67728935373945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a76aaf64dd10c735c67728935373945">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::imag </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>compVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the imaginary parts of every element of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compVec</td><td>a vector of complex numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the imaginary parts of the complex vector </dd></dl>

</div>
</div>
<a id="ga2cc509230677aaf94f75d70edf69f89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cc509230677aaf94f75d70edf69f89c">&#9670;&nbsp;</a></span>inert2LocalTangent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::inert2LocalTangent </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>inertPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_mer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert inertial coordinates to local tangent coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inertPos</td><td>Object position in inertial, cartesian (x,y,z) coordinates </td></tr>
    <tr><td class="paramname">lat</td><td>Latitude angle, radians, measured from the inertial xy plane; above the plane (z &gt; 0) is a positive latitude. </td></tr>
    <tr><td class="paramname">lon</td><td>Longitude angle, radians, measured from reference meridian in a positive, right-handed rotation about inertial z </td></tr>
    <tr><td class="paramname">theta_mer</td><td>Meridian longitude, radians, measured from inertial x in a positive, right-handed rotation about inertial z. For example, Earth ground stations' longitudes are relative to the Greenwich Meridian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the object in local tangent, cartesian coordinates (East, North, Up) as viewed from the specified latitude and longitude </dd></dl>

</div>
</div>
<a id="ga3c0f5dcd605acc6d0212181a69746844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c0f5dcd605acc6d0212181a69746844">&#9670;&nbsp;</a></span>interpPointAtTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classastrohelion_1_1_node.html">Node</a> astrohelion::interpPointAtTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classastrohelion_1_1_arcset.html">Arcset</a> *&#160;</td>
          <td class="paramname"><em>traj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use numerical integration to find a node on a trajectory at the specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traj</td><td>An arcset </td></tr>
    <tr><td class="paramname">t</td><td>The time at which the node is located</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A node on the specified trajectory at time <code>t</code> </dd></dl>

</div>
</div>
<a id="ga4d6ccbe0327d00b4e2e0ad30cbf0e744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d6ccbe0327d00b4e2e0ad30cbf0e744">&#9670;&nbsp;</a></span>localTangent2Inert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; astrohelion::localTangent2Inert </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>localPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>theta_mer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert local tangent coordinates to inertial coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">localPos</td><td>Object position in local tangent, cartesian (East, North, Up) coordinates </td></tr>
    <tr><td class="paramname">lat</td><td>Latitude angle, radians, measured from the inertial xy plane; above the plane (z &gt; 0) is a positive latitude. </td></tr>
    <tr><td class="paramname">lon</td><td>Longitude angle, radians, measured from reference meridian in a positive, right-handed rotation about inertial z </td></tr>
    <tr><td class="paramname">theta_mer</td><td>Meridian longitude, radians, measured from inertial x in a positive, right-handed rotation about inertial z. For example, Earth ground stations' longitudes are relative to the Greenwich Meridian </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the object in inertial, cartesian coordinates (x, y, z) as viewed from the specified latitude and longitude </dd></dl>

</div>
</div>
<a id="gac1ff60d4af4abee3c46c2895e200e7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1ff60d4af4abee3c46c2895e200e7c3">&#9670;&nbsp;</a></span>mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T astrohelion::mean </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean (average) of an array of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>an array of numbers </td></tr>
    <tr><td class="paramname">length</td><td>the length of the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mean </dd></dl>

</div>
</div>
<a id="ga145908792689d801e6f32baf855972bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga145908792689d801e6f32baf855972bc">&#9670;&nbsp;</a></span>mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T astrohelion::mean </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean (average) of a vector of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a vector of numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a numerical type, like int, double, long, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the mean </dd></dl>

</div>
</div>
<a id="ga027665ba49600ee4339eb7ccc902d28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga027665ba49600ee4339eb7ccc902d28e">&#9670;&nbsp;</a></span>permute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::permute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numSpots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>ixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>perms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Worker function to compute permutations via recursion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>a vector of all possible values for each element </td></tr>
    <tr><td class="paramname">numSpots</td><td>the number of elements, or "spots" </td></tr>
    <tr><td class="paramname">ixs</td><td>the indices of values for each element in the current permuation </td></tr>
    <tr><td class="paramname">perms</td><td>a pointer to a storage vector for the permutations; stored in row-major order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9ab2020c4b72bec9c8edc9c15f1b69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9ab2020c4b72bec9c8edc9c15f1b69d">&#9670;&nbsp;</a></span>permute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::permute </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt;&#160;</td>
          <td class="paramname"><em>ixs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>perms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Worker function to compute permutations via recursion without repeating values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>a vector of all possible values </td></tr>
    <tr><td class="paramname">ixs</td><td>the indices of values for each element in the current permutation </td></tr>
    <tr><td class="paramname">perms</td><td>a pointer to a storage vector for the permutations; stored in row-major order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0aa1c81b491a8022db82871f168bbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0aa1c81b491a8022db82871f168bbec">&#9670;&nbsp;</a></span>printColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::printColor </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to the standard output using an ASCII escape-type color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>one of the constant color values stored in the ascii-output header </td></tr>
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c62b88d77cf0935f4d74187423143e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c62b88d77cf0935f4d74187423143e6">&#9670;&nbsp;</a></span>printErr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::printErr </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print an error message to the standard output in red. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3b46b081f51bdb325b1e196564183ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3b46b081f51bdb325b1e196564183ae">&#9670;&nbsp;</a></span>printVerb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::printVerb </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A wrapper function to print a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>whether or not to be verbose; message is not printed if verbose is false </td></tr>
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa97e4e3ab8efb5ae96fa6d0d8cf018c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa97e4e3ab8efb5ae96fa6d0d8cf018c3">&#9670;&nbsp;</a></span>printVerbColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::printVerbColor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message to the standard output using an ASCII escape-type color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>whether or not to print the string </td></tr>
    <tr><td class="paramname">color</td><td>one of the constant color values stored in the ascii-output header </td></tr>
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48bfcd6112b39e450fd33621c7a67b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48bfcd6112b39e450fd33621c7a67b00">&#9670;&nbsp;</a></span>printWarn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::printWarn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a warning messate to the standard output in yellow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>a standard format string literal to pass to <code>vprintf</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf353962161fbf0c85dd7313165903068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf353962161fbf0c85dd7313165903068">&#9670;&nbsp;</a></span>readDoubleFromMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::readDoubleFromMat </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a double from a mat file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matFile</td><td>a pointer to the matlab file in quesiton </td></tr>
    <tr><td class="paramname">varName</td><td>the name of the variable in the mat file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the variable </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there is trouble reading or parsing the variable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga89fcd44ede02561762c5c005b35dab48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89fcd44ede02561762c5c005b35dab48">&#9670;&nbsp;</a></span>readMatrixFromMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a> astrohelion::readMatrixFromMat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a matrix of doubles from a .mat file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>relative or absolute path to the .mat data file </td></tr>
    <tr><td class="paramname">varName</td><td>the name of the variable/matrix to read from the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a column-major-order vector containing the data from the desired matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the file cannot be opened, if the variable doesn't exist, or if the variable contains something other than doubles </td></tr>
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if the data file cannot be opened or the variable cannot be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0e3858d1fdc7289cac1f8e09cac9ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0e3858d1fdc7289cac1f8e09cac9ef8">&#9670;&nbsp;</a></span>readStringFromMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string astrohelion::readStringFromMat </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matio_types&#160;</td>
          <td class="paramname"><em>aType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matio_classes&#160;</td>
          <td class="paramname"><em>aClass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a string from a matlab file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matFile</td><td>a pointer to the matlab file in questions </td></tr>
    <tr><td class="paramname">varName</td><td>the name of the variable in the mat file </td></tr>
    <tr><td class="paramname">aType</td><td>the expected variable type (e.g. MAT_T_UINT8) </td></tr>
    <tr><td class="paramname">aClass</td><td>the expected variable class (e.g. MAT_C_CHAR) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if there is trouble reading or parsing the variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6b14977397b33216fba702b2eafa8880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b14977397b33216fba702b2eafa8880">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; astrohelion::real </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>compVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real parts of every element of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compVec</td><td>a vector of complex numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of the real parts of the complex vector </dd></dl>

</div>
</div>
<a id="ga8b68c8eba2231ca76428b9414e6b1bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b68c8eba2231ca76428b9414e6b1bfc">&#9670;&nbsp;</a></span>resolveAngle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::resolveAngle </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>asinVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>acosVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve double angle ambiquity from inverse trig functions. </p>
<p>[long description]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asinVal</td><td>The result of arcsin(value) </td></tr>
    <tr><td class="paramname">acosVal</td><td>The result of arccos(value)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The common value between the double angles returned by arcsin(value) and arccos(value) </dd></dl>

</div>
</div>
<a id="ga4be30e012cbdb013c3fa4658e9131e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4be30e012cbdb013c3fa4658e9131e16">&#9670;&nbsp;</a></span>saveDoubleToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveDoubleToFile </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a single double-precision value to a Matlab file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matfp</td><td>a pointer to the matlab output file </td></tr>
    <tr><td class="paramname">varName</td><td>the name of the variable </td></tr>
    <tr><td class="paramname">data</td><td>data value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c3045a2c2270ba2e6e2ff0ed671d72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c3045a2c2270ba2e6e2ff0ed671d72c">&#9670;&nbsp;</a></span>saveMatrixToFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveMatrixToFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a matrix of data to a Matlab .mat file. </p>
<p>The data passed in the <code>data</code> vector is transposed and saved to the specified Matlab file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name/path of the file </td></tr>
    <tr><td class="paramname">varName</td><td>variable name </td></tr>
    <tr><td class="paramname">data</td><td>vector of data in row-major order </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15cf53228c93a84457dffacd64475a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15cf53228c93a84457dffacd64475a56">&#9670;&nbsp;</a></span>saveMatrixToFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveMatrixToFile </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a matrix of data to an open matlab .mat file. </p>
<p>The data passed in the <code>data</code> vector is transposed and saved to the specified Matlab file</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matfp</td><td>An open Matlab .mat file </td></tr>
    <tr><td class="paramname">varName</td><td>name of the variable within the .mat file </td></tr>
    <tr><td class="paramname">data</td><td>a vector of data in row-major order </td></tr>
    <tr><td class="paramname">rows</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramname">cols</td><td>number of columns in the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classastrohelion_1_1_exception.html" title="Base Exception class for all my exceptions. ">Exception</a></td><td>if <code>data</code> does not have enough elements to construct a matrix with the specified number of rows and columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga553ef6bddfc70952db18875f5df1e8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga553ef6bddfc70952db18875f5df1e8f2">&#9670;&nbsp;</a></span>saveVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::saveVar </td>
          <td>(</td>
          <td class="paramtype">mat_t *&#160;</td>
          <td class="paramname"><em>matFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matvar_t *&#160;</td>
          <td class="paramname"><em>matvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>varName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">matio_compression&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a variable to a .mat file, performing error checks along the way. </p>
<p>Once the variable is written to file, it is freed from memory, thus any further calls to Mat_VarFree on the matvar_t object will result in malloc errors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matFile</td><td>a pointer to the matlab output file </td></tr>
    <tr><td class="paramname">matvar</td><td>a pointer to the matlab variable object </td></tr>
    <tr><td class="paramname">varName</td><td>a literal string that describes the variable; only used in error message output </td></tr>
    <tr><td class="paramname">comp</td><td>an enum that describes the compression strategy. Options are: MAT_COMPRESSION_NONE - no compression MAT_COMPRESSION_ZLIB - zlib compression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85ebc44549945b1aec328349b1eb1133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85ebc44549945b1aec328349b1eb1133">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int astrohelion::sign </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sign of a number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>a number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>+/- 1 for the sign (0 if T = 0) </dd></dl>

</div>
</div>
<a id="ga777cfd117e90b9f00c95ae72116634ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga777cfd117e90b9f00c95ae72116634ea">&#9670;&nbsp;</a></span>sortEig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned int &gt; astrohelion::sortEig </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceastrohelion.html#adad21911fcb9bf6db78b0ee09397edd1">cdouble</a> &gt;&#160;</td>
          <td class="paramname"><em>eigVals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceastrohelion.html#a864c99da947f1112284463c6b1136310">MatrixXRcd</a> &gt;&#160;</td>
          <td class="paramname"><em>eigVecs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort eigenvalues. </p>
<p>This algorithm leverages three simple axioms to determine if the eigenvalues are in a consistent order. </p><pre class="fragment">1. Pairs of eigenvalues should occur in sequence ( [0,1] or [2,3], etc.) and have
a product equal to one (reciprocal pairs)

2. Eigenvalues evolve continuously along the family, thus the changes between subsequent 
eigenvalues should be small

3. Eigenvectors evolve continuously along the family, thus the dot product between subsequent
eigenvectors should be small
</pre><p>Axiom #1 is not always applicable to trajectories but is always applicable to families of periodic orbits in the CR3BP</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigVals</td><td>Vector of all eigenvalues along a family of trajectories. It is assumed that there are six eigenvalues per trajectory.</td></tr>
    <tr><td class="paramname">eigVecs</td><td>Vector of 6x6 eigenvector matrices; the eigenvectors are columns of the matrix and their order is consistent with the order of the six eigenvalues associated with the same trajectory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Rearranged indices that describe the correct order of the eigenvalues/vectors </dd></dl>

</div>
</div>
<a id="gab351385fdf91016b664acaecbcdb820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab351385fdf91016b664acaecbcdb820a">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T astrohelion::sum </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sum all values in an array </p>
<p>For this function to work, the class must overload +=</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>an array </td></tr>
    <tr><td class="paramname">length</td><td>the number of elements in the array that can be summed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a single object representing the sum of all the elements of data. </dd></dl>

</div>
</div>
<a id="ga2285370a44ae7b7a45b25b594d915eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2285370a44ae7b7a45b25b594d915eeb">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T astrohelion::sum </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum all values in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>a vector of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>numerical data type, like int, double, long, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum </dd></dl>

</div>
</div>
<a id="ga6dd9f78c54a562d9cbaa7f28c185a1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dd9f78c54a562d9cbaa7f28c185a1f7">&#9670;&nbsp;</a></span>to_underlying()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto astrohelion::to_underlying </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> -&gt; typename std::underlying_type&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly cast a strongly typed enumerate type to its underlying type. </p>
<p>For example, if an enum is declared as <code>enum class tp : int</code>, this function will cast any <code>tp::value</code> class to the underlying type, <code>int</code>. This is useful if you want to compare <code>int</code> values with the enum values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Object to retrieve the underlying type of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The underlying type of e. </dd></dl>

</div>
</div>
<a id="ga15e325e7da3ac2e72d23f4998a58e9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15e325e7da3ac2e72d23f4998a58e9be">&#9670;&nbsp;</a></span>toCSV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astrohelion::toCSV </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceastrohelion.html#a782f34ea53766b09a0c076f1cc70c011">MatrixXRd</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a matrix as a CSV file to be read by Excel or Matlab. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the matrix </td></tr>
    <tr><td class="paramname">filename</td><td>Filename of the csv file (include the .csv extension!) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccfdbcaf731eebb9523e329157f7a2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccfdbcaf731eebb9523e329157f7a2d6">&#9670;&nbsp;</a></span>wrapToPi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double astrohelion::wrapToPi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert and angle to its equivalent between -pi and pi. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>value in radians </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An equivalent value between -pi and pi </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
